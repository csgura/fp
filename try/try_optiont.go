// Code generated by monad_gen, DO NOT EDIT.
package try

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/option"
)

func PureOptionT[A any](a A) fp.Try[fp.Option[A]] {
	return Pure(option.Pure[A](a))
}

func LiftOptionT[A any](a fp.Try[A]) fp.Try[fp.Option[A]] {
	return Map(a, option.Pure[A])
}

func MapOptionT[A any, B any](t fp.Try[fp.Option[A]], f func(A) B) fp.Try[fp.Option[B]] {
	return Map(t, func(ma fp.Option[A]) fp.Option[B] {
		return option.FlatMap[A, B](ma, func(a A) fp.Option[B] {
			return option.Pure[B](f(a))
		})
	})
}

func SubFlatMapOptionT[A any, B any](t fp.Try[fp.Option[A]], f func(A) fp.Option[B]) fp.Try[fp.Option[B]] {
	return Map(t, func(ma fp.Option[A]) fp.Option[B] {
		return option.FlatMap[A, B](ma, func(a A) fp.Option[B] {
			return f(a)
		})
	})
}

func TraverseOptionT[A any, B any](t fp.Try[fp.Option[A]], f func(A) fp.Try[B]) fp.Try[fp.Option[B]] {
	sequencef := func(v fp.Option[fp.Try[B]]) fp.Try[fp.Option[B]] {
		if v.IsDefined() {
			return Map(v.Get(), option.Some)
		}
		return Success(fp.Option[B]{})
	}
	return FlatMap(MapOptionT(t, f), sequencef)
}

func FlatMapOptionT[A any, B any](t fp.Try[fp.Option[A]], f func(A) fp.Try[fp.Option[B]]) fp.Try[fp.Option[B]] {

	flatten := func(v fp.Option[fp.Option[B]]) fp.Option[B] {
		return option.FlatMap[fp.Option[B], B](v, fp.Id)
	}

	return Map(TraverseOptionT(t, f), flatten)

}

func OptionTFilter[A any](optionT fp.Try[fp.Option[A]], p func(v A) bool) fp.Try[fp.Option[A]] {
	return Map(optionT, func(insideValue fp.Option[A]) fp.Option[A] {
		return fp.Option[A].Filter(insideValue, p)
	})
}

func OptionTOrElse[A any](optionT fp.Try[fp.Option[A]], t A) fp.Try[A] {
	return Map(optionT, func(insideValue fp.Option[A]) A {
		return fp.Option[A].OrElse(insideValue, t)
	})
}

func OptionTOrZero[A any](optionT fp.Try[fp.Option[A]]) fp.Try[A] {
	return Map(optionT, func(insideValue fp.Option[A]) A {
		return fp.Option[A].OrZero(insideValue)
	})
}

func OptionTOrElseGet[A any](optionT fp.Try[fp.Option[A]], f func() A) fp.Try[A] {
	return Map(optionT, func(insideValue fp.Option[A]) A {
		return fp.Option[A].OrElseGet(insideValue, f)
	})
}

func OptionTOr[A any](optionT fp.Try[fp.Option[A]], f func() fp.Option[A]) fp.Try[fp.Option[A]] {
	return Map(optionT, func(insideValue fp.Option[A]) fp.Option[A] {
		return fp.Option[A].Or(insideValue, f)
	})
}

func OptionTOrOption[A any](optionT fp.Try[fp.Option[A]], v fp.Option[A]) fp.Try[fp.Option[A]] {
	return Map(optionT, func(insideValue fp.Option[A]) fp.Option[A] {
		return fp.Option[A].OrOption(insideValue, v)
	})
}

func OptionTOrPtr[A any](optionT fp.Try[fp.Option[A]], v *A) fp.Try[fp.Option[A]] {
	return Map(optionT, func(insideValue fp.Option[A]) fp.Option[A] {
		return fp.Option[A].OrPtr(insideValue, v)
	})
}

func OptionTRecover[A any](optionT fp.Try[fp.Option[A]], f func() A) fp.Try[fp.Option[A]] {
	return Map(optionT, func(insideValue fp.Option[A]) fp.Option[A] {
		return fp.Option[A].Recover(insideValue, f)
	})
}

func OptionTFold[A any, B any](optionT fp.Try[fp.Option[A]], zero B, f func(B, A) B) fp.Try[B] {
	return Map(optionT, func(insideValue fp.Option[A]) B {
		return option.Fold[A, B](insideValue, zero, f)
	})
}
