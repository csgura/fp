// Code generated by monad_gen, DO NOT EDIT.
package optiont

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/iterator"
)

func Traverse[A any, R any](ia fp.Iterator[A], fn func(A) fp.PtrT[R]) fp.PtrT[fp.Iterator[R]] {
	return Map(FoldM(ia, fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.PtrT[fp.Seq[R]] {
		return Map(fn(a), acc.Add)
	}), iterator.FromSeq)
}

func TraverseSeq[A any, R any](sa fp.Seq[A], fa func(A) fp.PtrT[R]) fp.PtrT[fp.Seq[R]] {
	return FoldM(fp.IteratorOfSeq(sa), fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.PtrT[fp.Seq[R]] {
		return Map(fa(a), acc.Add)
	})
}

func TraverseSlice[A any, R any](sa []A, fa func(A) fp.PtrT[R]) fp.PtrT[[]R] {
	return Map(TraverseSeq(sa, fa), fp.Seq[R].Widen)
}

func TraverseFunc[A any, R any](far func(A) fp.PtrT[R]) func(fp.Iterator[A]) fp.PtrT[fp.Iterator[R]] {
	return func(iterA fp.Iterator[A]) fp.PtrT[fp.Iterator[R]] {
		return Traverse(iterA, far)
	}
}

func TraverseSeqFunc[A any, R any](far func(A) fp.PtrT[R]) func(fp.Seq[A]) fp.PtrT[fp.Seq[R]] {
	return func(seqA fp.Seq[A]) fp.PtrT[fp.Seq[R]] {
		return TraverseSeq(seqA, far)
	}
}

func TraverseSliceFunc[A any, R any](far func(A) fp.PtrT[R]) func([]A) fp.PtrT[[]R] {
	return func(seqA []A) fp.PtrT[[]R] {
		return TraverseSlice(seqA, far)
	}
}

func FlatMapTraverseSeq[A any, B any](ta fp.PtrT[fp.Seq[A]], f func(v A) fp.PtrT[B]) fp.PtrT[fp.Seq[B]] {
	return FlatMap(ta, TraverseSeqFunc(f))
}

func FlatMapTraverseSlice[A any, B any](ta fp.PtrT[[]A], f func(v A) fp.PtrT[B]) fp.PtrT[[]B] {
	return FlatMap(ta, TraverseSliceFunc(f))
}

func Sequence[A any](tsa []fp.PtrT[A]) fp.PtrT[[]A] {
	ret := FoldM(iterator.FromSlice(tsa), fp.Slice[A]{}, func(t1 fp.Slice[A], t2 fp.PtrT[A]) fp.PtrT[fp.Slice[A]] {
		return Map(t2, func(v A) fp.Slice[A] {
			return append(t1, v)
		})
	})

	return ret
}

func SequenceIterator[A any](ita fp.Iterator[fp.PtrT[A]]) fp.PtrT[fp.Iterator[A]] {
	ret := FoldM(ita, fp.Seq[A]{}, func(t1 fp.Seq[A], t2 fp.PtrT[A]) fp.PtrT[fp.Seq[A]] {
		return Map(t2, t1.Add)
	})
	return Map(ret, iterator.FromSeq)

}
