// Code generated by gombok, DO NOT EDIT.
package statet

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/iterator"
)

func Traverse[S any, A any, R any](ia fp.Iterator[A], fn func(A) fp.StateT[S, R]) fp.StateT[S, fp.Iterator[R]] {
	return Map(FoldM(ia, fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.StateT[S, fp.Seq[R]] {
		return Map(fn(a), acc.Add)
	}), iterator.FromSeq)
}

func TraverseSeq[S any, A any, R any](sa fp.Seq[A], fa func(A) fp.StateT[S, R]) fp.StateT[S, fp.Seq[R]] {
	return FoldM(fp.IteratorOfSeq(sa), fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.StateT[S, fp.Seq[R]] {
		return Map(fa(a), acc.Add)
	})
}

func TraverseSlice[S any, A any, R any](sa []A, fa func(A) fp.StateT[S, R]) fp.StateT[S, []R] {
	return Map(TraverseSeq(sa, fa), fp.Seq[R].Widen)
}

func TraverseFunc[S any, A any, R any](far func(A) fp.StateT[S, R]) func(fp.Iterator[A]) fp.StateT[S, fp.Iterator[R]] {
	return func(iterA fp.Iterator[A]) fp.StateT[S, fp.Iterator[R]] {
		return Traverse(iterA, far)
	}
}

func TraverseSeqFunc[S any, A any, R any](far func(A) fp.StateT[S, R]) func(fp.Seq[A]) fp.StateT[S, fp.Seq[R]] {
	return func(seqA fp.Seq[A]) fp.StateT[S, fp.Seq[R]] {
		return TraverseSeq(seqA, far)
	}
}

func TraverseSliceFunc[S any, A any, R any](far func(A) fp.StateT[S, R]) func([]A) fp.StateT[S, []R] {
	return func(seqA []A) fp.StateT[S, []R] {
		return TraverseSlice(seqA, far)
	}
}

func FlatMapTraverseSeq[S any, A any, B any](ta fp.StateT[S, fp.Seq[A]], f func(v A) fp.StateT[S, B]) fp.StateT[S, fp.Seq[B]] {
	return FlatMap(ta, TraverseSeqFunc(f))
}

func FlatMapTraverseSlice[S any, A any, B any](ta fp.StateT[S, []A], f func(v A) fp.StateT[S, B]) fp.StateT[S, []B] {
	return FlatMap(ta, TraverseSliceFunc(f))
}

func Sequence[S any, A any](tsa []fp.StateT[S, A]) fp.StateT[S, []A] {
	ret := FoldM(iterator.FromSeq(tsa), fp.Seq[A]{}, func(t1 fp.Seq[A], t2 fp.StateT[S, A]) fp.StateT[S, fp.Seq[A]] {
		return Map(t2, t1.Add)
	})

	return Map(ret, fp.Seq[A].Widen)
}

func SequenceIterator[S any, A any](ita fp.Iterator[fp.StateT[S, A]]) fp.StateT[S, fp.Iterator[A]] {
	ret := FoldM(ita, fp.Seq[A]{}, func(t1 fp.Seq[A], t2 fp.StateT[S, A]) fp.StateT[S, fp.Seq[A]] {
		return Map(t2, t1.Add)
	})
	return Map(ret, iterator.FromSeq)

}
