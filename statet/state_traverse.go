// Code generated by gombok, DO NOT EDIT.
package statet

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/iterator"
)

// generated by statet_op.go:23

func TraverseSeq[S any, A any, R any](sa fp.Seq[A], fa func(A) fp.StateT[S, R]) fp.StateT[S, fp.Seq[R]] {
	return FoldM(fp.IteratorOfSeq(sa), fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.StateT[S, fp.Seq[R]] {
		return Map(fa(a), acc.Add)
	})
}

func TraverseSlice[S any, A any, R any](sa fp.Slice[A], fa func(A) fp.StateT[S, R]) fp.StateT[S, fp.Slice[R]] {
	return FoldM(fp.IteratorOfSeq(sa), fp.Slice[R]{}, func(acc fp.Slice[R], a A) fp.StateT[S, fp.Slice[R]] {
		return Map(fa(a), func(v R) fp.Slice[R] {
			return append(acc, v)
		})
	})
}

func Sequence[S any, A any](tsa []fp.StateT[S, A]) fp.StateT[S, fp.Slice[A]] {
	ret := FoldM(iterator.FromSlice(tsa), fp.Slice[A]{}, func(t1 fp.Slice[A], t2 fp.StateT[S, A]) fp.StateT[S, fp.Slice[A]] {
		return Map(t2, func(v A) fp.Slice[A] {
			return append(t1, v)
		})
	})

	return ret
}

func Traverse[S any, A any, R any](ia fp.Iterator[A], fn func(A) fp.StateT[S, R]) fp.StateT[S, fp.Iterator[R]] {
	return Map(FoldM(ia, fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.StateT[S, fp.Seq[R]] {
		return Map(fn(a), acc.Add)
	}), iterator.FromSeq)
}

func TraverseFunc[S any, A any, R any](far func(A) fp.StateT[S, R]) func(fp.Iterator[A]) fp.StateT[S, fp.Iterator[R]] {
	return func(iterA fp.Iterator[A]) fp.StateT[S, fp.Iterator[R]] {
		return Traverse(iterA, far)
	}
}

func TraverseSeqFunc[S any, A any, R any](far func(A) fp.StateT[S, R]) func(fp.Seq[A]) fp.StateT[S, fp.Seq[R]] {
	return func(seqA fp.Seq[A]) fp.StateT[S, fp.Seq[R]] {
		return TraverseSeq(seqA, far)
	}
}

func TraverseSliceFunc[S any, A any, R any](far func(A) fp.StateT[S, R]) func(fp.Slice[A]) fp.StateT[S, fp.Slice[R]] {
	return func(seqA fp.Slice[A]) fp.StateT[S, fp.Slice[R]] {
		return TraverseSlice(seqA, far)
	}
}

func FlatMapTraverseSeq[S any, A any, B any](ta fp.StateT[S, fp.Seq[A]], f func(v A) fp.StateT[S, B]) fp.StateT[S, fp.Seq[B]] {
	return FlatMap(ta, TraverseSeqFunc(f))
}

func FlatMapTraverseSlice[S any, A any, B any](ta fp.StateT[S, fp.Slice[A]], f func(v A) fp.StateT[S, B]) fp.StateT[S, fp.Slice[B]] {
	return FlatMap(ta, TraverseSliceFunc(f))
}

func SequenceIterator[S any, A any](ita fp.Iterator[fp.StateT[S, A]]) fp.StateT[S, fp.Iterator[A]] {
	ret := FoldM(ita, fp.Seq[A]{}, func(t1 fp.Seq[A], t2 fp.StateT[S, A]) fp.StateT[S, fp.Seq[A]] {
		return Map(t2, t1.Add)
	})
	return Map(ret, iterator.FromSeq)

}
