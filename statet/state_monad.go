// Code generated by gombok, DO NOT EDIT.
package statet

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/curried"
	"github.com/csgura/fp/iterator"
	"github.com/csgura/fp/product"
	"github.com/csgura/fp/xtr"
)

// generated by statet_op.go:15

func Flatten[S any, A any](tta fp.StateT[S, fp.StateT[S, A]]) fp.StateT[S, A] {
	return FlatMap(tta, func(v fp.StateT[S, A]) fp.StateT[S, A] {
		return v
	})
}

func Map[S any, A any, R any](m fp.StateT[S, A], f func(A) R) fp.StateT[S, R] {
	return FlatMap(m, fp.Compose2(f, Pure[S, R]))
}

// haskell 의 <$
// map . const 와 같은 함수
func Replace[S any, A any, R any](s fp.StateT[S, A], b R) fp.StateT[S, R] {
	return Map(s, fp.Const[A](b))
}

func Map2[S any, A any, B, R any](first fp.StateT[S, A], second fp.StateT[S, B], fab func(A, B) R) fp.StateT[S, R] {
	return FlatMap(first, func(a A) fp.StateT[S, R] {
		return Map(second, func(b B) R {
			return fab(a, b)
		})
	})
}

func Zip[S any, A any, B any](first fp.StateT[S, A], second fp.StateT[S, B]) fp.StateT[S, fp.Tuple2[A, B]] {
	return Map2(first, second, product.Tuple2)
}

func Ap[S any, A any, B any](tfab fp.StateT[S, fp.Func1[A, B]], ta fp.StateT[S, A]) fp.StateT[S, B] {
	return FlatMap(tfab, func(fab fp.Func1[A, B]) fp.StateT[S, B] {
		return Map(ta, fab)
	})
}

func Compose[S any, A any, B, C any](f1 func(A) fp.StateT[S, B], f2 func(B) fp.StateT[S, C]) func(A) fp.StateT[S, C] {
	return func(a A) fp.StateT[S, C] {
		return FlatMap(f1(a), f2)
	}
}

func Compose2[S any, A any, B, C any](f1 func(A) fp.StateT[S, B], f2 func(B) fp.StateT[S, C]) func(A) fp.StateT[S, C] {
	return func(a A) fp.StateT[S, C] {
		return FlatMap(f1(a), f2)
	}
}

func ApFunc[S any, A any, B any](tfab fp.StateT[S, fp.Func1[A, B]], ta func() fp.StateT[S, A]) fp.StateT[S, B] {
	return FlatMap(tfab, func(fab fp.Func1[A, B]) fp.StateT[S, B] {
		return Map(ta(), fab)
	})
}

// Map(ta , seq.Lift(f)) 와 동일
func MapSeqLift[S any, A any, B any](ta fp.StateT[S, fp.Seq[A]], f func(v A) B) fp.StateT[S, fp.Seq[B]] {

	return Map(ta, func(a fp.Seq[A]) fp.Seq[B] {
		return iterator.Map(iterator.FromSeq(a), f).ToSeq()
	})
}

// Map(ta , seq.Lift(f)) 와 동일
func MapSliceLift[S any, A any, B any](ta fp.StateT[S, []A], f func(v A) B) fp.StateT[S, []B] {

	return Map(ta, func(a []A) []B {
		return iterator.Map(iterator.FromSeq(a), f).ToSeq()
	})
}

func Lift[S any, A any, R any](fa func(v A) R) func(fp.StateT[S, A]) fp.StateT[S, R] {
	return func(ta fp.StateT[S, A]) fp.StateT[S, R] {
		return Map(ta, fa)
	}
}

func LiftA2[S any, A any, B, R any](fab func(A, B) R) func(fp.StateT[S, A], fp.StateT[S, B]) fp.StateT[S, R] {
	return func(a fp.StateT[S, A], b fp.StateT[S, B]) fp.StateT[S, R] {
		return Map2(a, b, fab)
	}
}

func LiftM[S any, A any, R any](fa func(v A) fp.StateT[S, R]) func(fp.StateT[S, A]) fp.StateT[S, R] {
	return func(ta fp.StateT[S, A]) fp.StateT[S, R] {
		return Flatten(Map(ta, fa))
	}
}

// (a -> b -> m r) -> m a -> m b -> m r
// 하스켈에서는  liftM2 와 liftA2 는 같은 함수이고
// 위와 같은 함수는 존재하지 않음.
// hoogle 에서 검색해 보면 , liftJoin2 , bindM2 등의 이름으로 정의된 것이 있음.
// 하지만 ,  fp 패키지에서도   LiftA2 와 LiftM2 를 동일하게 하는 것은 낭비이고
// M 은 Monad 라는 뜻인데, Monad는 Flatten, FlatMap 의 의미가 있으니까
// LiftM2 를 다음과 같이 정의함.
func LiftM2[S any, A any, B, R any](fab func(A, B) fp.StateT[S, R]) func(fp.StateT[S, A], fp.StateT[S, B]) fp.StateT[S, R] {
	return func(a fp.StateT[S, A], b fp.StateT[S, B]) fp.StateT[S, R] {
		return Flatten(Map2(a, b, fab))
	}
}

func FlatMap2[S any, A any, B, R any](first fp.StateT[S, A], second fp.StateT[S, B], fab func(A, B) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM2(fab)(first, second)
}

// 하스켈 : m( a -> r ) -> a -> m r
// 스칼라 : M[ A => r ] => A => M[R]
// 하스켈이나 스칼라의 기본 패키지에는 이런 기능을 하는 함수가 없는데,
// hoogle 에서 검색해 보면
// https://hoogle.haskell.org/?hoogle=m%20(%20a%20-%3E%20b)%20-%3E%20a%20-%3E%20m%20b
// ?? 혹은 flap 이라는 이름으로 정의된 함수가 있음
func Flap[S any, A any, R any](tfa fp.StateT[S, fp.Func1[A, R]]) func(A) fp.StateT[S, R] {
	return func(a A) fp.StateT[S, R] {
		return Ap(tfa, Pure[S](a))
	}
}

// 하스켈 : m( a -> b -> r ) -> a -> b -> m r
func Flap2[S any, A any, B, R any](tfab fp.StateT[S, fp.Func1[A, fp.Func1[B, R]]]) fp.Func1[A, fp.Func1[B, fp.StateT[S, R]]] {
	return func(a A) fp.Func1[B, fp.StateT[S, R]] {
		return Flap(Ap(tfab, Pure[S](a)))
	}
}

// (a -> b -> r) -> m a -> b -> m r
// Map 호출 후에 Flap 을 호출 한 것
//
// https://hoogle.haskell.org/?hoogle=%28+a+-%3E+b+-%3E++r+%29+-%3E+m+a+-%3E++b+-%3E+m+r+&scope=set%3Astackage
// liftOp 라는 이름으로 정의된 것이 있음
func FlapMap[S any, A any, B, R any](tfab func(A, B) R, a fp.StateT[S, A]) func(B) fp.StateT[S, R] {
	return Flap(Map(a, curried.Func2(tfab)))
}

// ( a -> b -> m r) -> m a -> b -> m r
//
//	Flatten . FlapMap
//
// https://hoogle.haskell.org/?hoogle=(%20a%20-%3E%20b%20-%3E%20m%20r%20)%20-%3E%20m%20a%20-%3E%20%20b%20-%3E%20m%20r%20
// om , ==<<  이름으로 정의된 것이 있음
func FlatFlapMap[S any, A any, B, R any](fab func(A, B) fp.StateT[S, R], ta fp.StateT[S, A]) func(B) fp.StateT[S, R] {
	return fp.Compose(FlapMap(fab, ta), Flatten[S, R])
}

// FlatMap 과는 아규먼트 순서가 다른 함수로
// Go 나 Java 에서는 메소드 레퍼런스를 이용하여,  객체내의 메소드를 리턴 타입만 lift 된 형태로 리턴하게 할 수 있음.
// Method 라는 이름보다  Ap 와 비슷한 이름이 좋을 거 같은데
// Ap와 비슷한 이름으로 하기에는 Ap 와 타입이 너무 다름.
func Method1[S any, A any, B, R any](ta fp.StateT[S, A], fab func(a A, b B) R) func(B) fp.StateT[S, R] {
	return FlapMap(fab, ta)
}

func FlatMethod1[S any, A any, B, R any](ta fp.StateT[S, A], fab func(a A, b B) fp.StateT[S, R]) func(B) fp.StateT[S, R] {
	return FlatFlapMap(fab, ta)
}

func Method2[S any, A any, B, C, R any](ta fp.StateT[S, A], fabc func(a A, b B, c C) R) func(B, C) fp.StateT[S, R] {

	return curried.Revert2(Flap2(Map(ta, curried.Func3(fabc))))
	// return func(b B, c C) fp.StateT[S,R] {
	// 	return Map(a, func(a A) R {
	// 		return cf(a, b, c)
	// 	})
	// }
}

func FlatMethod2[S any, A any, B, C, R any](ta fp.StateT[S, A], fabc func(a A, b B, c C) fp.StateT[S, R]) func(B, C) fp.StateT[S, R] {

	return curried.Revert2(curried.Compose2(Flap2(Map(ta, curried.Func3(fabc))), Flatten[S, R]))

	// return func(b B, c C) fp.StateT[S,R] {
	// 	return FlatMap(ta, func(a A) fp.StateT[S,R] {
	// 		return cf(a, b, c)
	// 	})
	// }
}

func UnZip[S any, A any, B any](t fp.StateT[S, fp.Tuple2[A, B]]) (fp.StateT[S, A], fp.StateT[S, B]) {
	return Map(t, xtr.Head), Map(t, xtr.Tail)
}

func Zip3[S any, A any, B, C any](ta fp.StateT[S, A], tb fp.StateT[S, B], tc fp.StateT[S, C]) fp.StateT[S, fp.Tuple3[A, B, C]] {
	return LiftA3[S](product.Tuple3[A, B, C])(ta, tb, tc)
}

// fp.With 의 try 버젼
// fp.With 가 Flip 과 사실상 같은 것처럼
// FlapMap 의 Flip 버젼과 동일
// var b fp.Try[B]
// a := try.Sucesss(A{})
// a.FlatMap( try.With(A.WithB, b))
// 형태로 코딩 가능
func With[S any, A any, B any](withf func(A, B) A, v fp.StateT[S, B]) func(A) fp.StateT[S, A] {
	return Flap(Map(v, fp.Flip2(withf)))
}

func LiftA3[S any, A1 any, A2, A3, R any](f func(a1 A1, a2 A2, a3 A3) R) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftA2[S](func(a2 A2, a3 A3) R {
				return f(a1, a2, a3)
			})(ins2, ins3)
		})
	}
}

func LiftA4[S any, A1 any, A2, A3, A4, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4) R) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftA3[S](func(a2 A2, a3 A3, a4 A4) R {
				return f(a1, a2, a3, a4)
			})(ins2, ins3, ins4)
		})
	}
}

func LiftA5[S any, A1 any, A2, A3, A4, A5, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) R) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftA4[S](func(a2 A2, a3 A3, a4 A4, a5 A5) R {
				return f(a1, a2, a3, a4, a5)
			})(ins2, ins3, ins4, ins5)
		})
	}
}

func LiftA6[S any, A1 any, A2, A3, A4, A5, A6, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftA5[S](func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R {
				return f(a1, a2, a3, a4, a5, a6)
			})(ins2, ins3, ins4, ins5, ins6)
		})
	}
}

func LiftA7[S any, A1 any, A2, A3, A4, A5, A6, A7, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6], fp.StateT[S, A7]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftA6[S](func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R {
				return f(a1, a2, a3, a4, a5, a6, a7)
			})(ins2, ins3, ins4, ins5, ins6, ins7)
		})
	}
}

func LiftA8[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6], fp.StateT[S, A7], fp.StateT[S, A8]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftA7[S](func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R {
				return f(a1, a2, a3, a4, a5, a6, a7, a8)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8)
		})
	}
}

func LiftA9[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6], fp.StateT[S, A7], fp.StateT[S, A8], fp.StateT[S, A9]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8], ins9 fp.StateT[S, A9]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftA8[S](func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R {
				return f(a1, a2, a3, a4, a5, a6, a7, a8, a9)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
		})
	}
}

func Map3[S any, A1 any, A2, A3, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], f func(a1 A1, a2 A2, a3 A3) R) fp.StateT[S, R] {
	return LiftA3[S](f)(ins1, ins2, ins3)
}

func Map4[S any, A1 any, A2, A3, A4, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], f func(a1 A1, a2 A2, a3 A3, a4 A4) R) fp.StateT[S, R] {
	return LiftA4[S](f)(ins1, ins2, ins3, ins4)
}

func Map5[S any, A1 any, A2, A3, A4, A5, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) R) fp.StateT[S, R] {
	return LiftA5[S](f)(ins1, ins2, ins3, ins4, ins5)
}

func Map6[S any, A1 any, A2, A3, A4, A5, A6, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R) fp.StateT[S, R] {
	return LiftA6[S](f)(ins1, ins2, ins3, ins4, ins5, ins6)
}

func Map7[S any, A1 any, A2, A3, A4, A5, A6, A7, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R) fp.StateT[S, R] {
	return LiftA7[S](f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7)
}

func Map8[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R) fp.StateT[S, R] {
	return LiftA8[S](f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8)
}

func Map9[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8], ins9 fp.StateT[S, A9], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R) fp.StateT[S, R] {
	return LiftA9[S](f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
}

func LiftM3[S any, A1 any, A2, A3, R any](f func(a1 A1, a2 A2, a3 A3) fp.StateT[S, R]) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftM2(func(a2 A2, a3 A3) fp.StateT[S, R] {
				return f(a1, a2, a3)
			})(ins2, ins3)
		})
	}
}

func LiftM4[S any, A1 any, A2, A3, A4, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4) fp.StateT[S, R]) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftM3(func(a2 A2, a3 A3, a4 A4) fp.StateT[S, R] {
				return f(a1, a2, a3, a4)
			})(ins2, ins3, ins4)
		})
	}
}

func LiftM5[S any, A1 any, A2, A3, A4, A5, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) fp.StateT[S, R]) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftM4(func(a2 A2, a3 A3, a4 A4, a5 A5) fp.StateT[S, R] {
				return f(a1, a2, a3, a4, a5)
			})(ins2, ins3, ins4, ins5)
		})
	}
}

func LiftM6[S any, A1 any, A2, A3, A4, A5, A6, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.StateT[S, R]) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftM5(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.StateT[S, R] {
				return f(a1, a2, a3, a4, a5, a6)
			})(ins2, ins3, ins4, ins5, ins6)
		})
	}
}

func LiftM7[S any, A1 any, A2, A3, A4, A5, A6, A7, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.StateT[S, R]) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6], fp.StateT[S, A7]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftM6(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.StateT[S, R] {
				return f(a1, a2, a3, a4, a5, a6, a7)
			})(ins2, ins3, ins4, ins5, ins6, ins7)
		})
	}
}

func LiftM8[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.StateT[S, R]) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6], fp.StateT[S, A7], fp.StateT[S, A8]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftM7(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.StateT[S, R] {
				return f(a1, a2, a3, a4, a5, a6, a7, a8)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8)
		})
	}
}

func LiftM9[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.StateT[S, R]) func(fp.StateT[S, A1], fp.StateT[S, A2], fp.StateT[S, A3], fp.StateT[S, A4], fp.StateT[S, A5], fp.StateT[S, A6], fp.StateT[S, A7], fp.StateT[S, A8], fp.StateT[S, A9]) fp.StateT[S, R] {
	return func(ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8], ins9 fp.StateT[S, A9]) fp.StateT[S, R] {

		return FlatMap(ins1, func(a1 A1) fp.StateT[S, R] {
			return LiftM8(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.StateT[S, R] {
				return f(a1, a2, a3, a4, a5, a6, a7, a8, a9)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
		})
	}
}

func FlatMap3[S any, A1 any, A2, A3, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], f func(a1 A1, a2 A2, a3 A3) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM3(f)(ins1, ins2, ins3)
}

func FlatMap4[S any, A1 any, A2, A3, A4, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], f func(a1 A1, a2 A2, a3 A3, a4 A4) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM4(f)(ins1, ins2, ins3, ins4)
}

func FlatMap5[S any, A1 any, A2, A3, A4, A5, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM5(f)(ins1, ins2, ins3, ins4, ins5)
}

func FlatMap6[S any, A1 any, A2, A3, A4, A5, A6, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM6(f)(ins1, ins2, ins3, ins4, ins5, ins6)
}

func FlatMap7[S any, A1 any, A2, A3, A4, A5, A6, A7, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM7(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7)
}

func FlatMap8[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM8(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8)
}

func FlatMap9[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ins1 fp.StateT[S, A1], ins2 fp.StateT[S, A2], ins3 fp.StateT[S, A3], ins4 fp.StateT[S, A4], ins5 fp.StateT[S, A5], ins6 fp.StateT[S, A6], ins7 fp.StateT[S, A7], ins8 fp.StateT[S, A8], ins9 fp.StateT[S, A9], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.StateT[S, R]) fp.StateT[S, R] {
	return LiftM9(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
}

func Flap3[S any, A1 any, A2, A3, R any](tf fp.StateT[S, fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, R]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.StateT[S, R]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.StateT[S, R]]] {
		return Flap2(Ap(tf, Pure[S](a1)))
	}
}

func Flap4[S any, A1 any, A2, A3, A4, R any](tf fp.StateT[S, fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, R]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.StateT[S, R]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.StateT[S, R]]]] {
		return Flap3(Ap(tf, Pure[S](a1)))
	}
}

func Flap5[S any, A1 any, A2, A3, A4, A5, R any](tf fp.StateT[S, fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, R]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.StateT[S, R]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.StateT[S, R]]]]] {
		return Flap4(Ap(tf, Pure[S](a1)))
	}
}

func Flap6[S any, A1 any, A2, A3, A4, A5, A6, R any](tf fp.StateT[S, fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, R]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.StateT[S, R]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.StateT[S, R]]]]]] {
		return Flap5(Ap(tf, Pure[S](a1)))
	}
}

func Flap7[S any, A1 any, A2, A3, A4, A5, A6, A7, R any](tf fp.StateT[S, fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, R]]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.StateT[S, R]]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.StateT[S, R]]]]]]] {
		return Flap6(Ap(tf, Pure[S](a1)))
	}
}

func Flap8[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, R any](tf fp.StateT[S, fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, R]]]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.StateT[S, R]]]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.StateT[S, R]]]]]]]] {
		return Flap7(Ap(tf, Pure[S](a1)))
	}
}

func Flap9[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](tf fp.StateT[S, fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.Func1[A9, R]]]]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.Func1[A9, fp.StateT[S, R]]]]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.Func1[A9, fp.StateT[S, R]]]]]]]]] {
		return Flap8(Ap(tf, Pure[S](a1)))
	}
}

func Method3[S any, A1 any, A2, A3, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3) R) func(A2, A3) fp.StateT[S, R] {
	return func(a2 A2, a3 A3) fp.StateT[S, R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3)
		})
	}
}

func Method4[S any, A1 any, A2, A3, A4, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4) R) func(A2, A3, A4) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4) fp.StateT[S, R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4)
		})
	}
}

func Method5[S any, A1 any, A2, A3, A4, A5, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) R) func(A2, A3, A4, A5) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5) fp.StateT[S, R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5)
		})
	}
}

func Method6[S any, A1 any, A2, A3, A4, A5, A6, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R) func(A2, A3, A4, A5, A6) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.StateT[S, R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6)
		})
	}
}

func Method7[S any, A1 any, A2, A3, A4, A5, A6, A7, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R) func(A2, A3, A4, A5, A6, A7) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.StateT[S, R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6, a7)
		})
	}
}

func Method8[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R) func(A2, A3, A4, A5, A6, A7, A8) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.StateT[S, R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
}

func Method9[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R) func(A2, A3, A4, A5, A6, A7, A8, A9) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.StateT[S, R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
}

func FlatMethod3[S any, A1 any, A2, A3, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3) fp.StateT[S, R]) func(A2, A3) fp.StateT[S, R] {
	return func(a2 A2, a3 A3) fp.StateT[S, R] {
		return FlatMap(ta1, func(a1 A1) fp.StateT[S, R] {
			return fa1(a1, a2, a3)
		})
	}
}

func FlatMethod4[S any, A1 any, A2, A3, A4, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4) fp.StateT[S, R]) func(A2, A3, A4) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4) fp.StateT[S, R] {
		return FlatMap(ta1, func(a1 A1) fp.StateT[S, R] {
			return fa1(a1, a2, a3, a4)
		})
	}
}

func FlatMethod5[S any, A1 any, A2, A3, A4, A5, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) fp.StateT[S, R]) func(A2, A3, A4, A5) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5) fp.StateT[S, R] {
		return FlatMap(ta1, func(a1 A1) fp.StateT[S, R] {
			return fa1(a1, a2, a3, a4, a5)
		})
	}
}

func FlatMethod6[S any, A1 any, A2, A3, A4, A5, A6, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.StateT[S, R]) func(A2, A3, A4, A5, A6) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.StateT[S, R] {
		return FlatMap(ta1, func(a1 A1) fp.StateT[S, R] {
			return fa1(a1, a2, a3, a4, a5, a6)
		})
	}
}

func FlatMethod7[S any, A1 any, A2, A3, A4, A5, A6, A7, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.StateT[S, R]) func(A2, A3, A4, A5, A6, A7) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.StateT[S, R] {
		return FlatMap(ta1, func(a1 A1) fp.StateT[S, R] {
			return fa1(a1, a2, a3, a4, a5, a6, a7)
		})
	}
}

func FlatMethod8[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.StateT[S, R]) func(A2, A3, A4, A5, A6, A7, A8) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.StateT[S, R] {
		return FlatMap(ta1, func(a1 A1) fp.StateT[S, R] {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
}

func FlatMethod9[S any, A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ta1 fp.StateT[S, A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.StateT[S, R]) func(A2, A3, A4, A5, A6, A7, A8, A9) fp.StateT[S, R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.StateT[S, R] {
		return FlatMap(ta1, func(a1 A1) fp.StateT[S, R] {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
}

func Compose3[S any, A1 any, A2, A3, R any](f1 fp.Func1[A1, fp.StateT[S, A2]], f2 fp.Func1[A2, fp.StateT[S, A3]], f3 fp.Func1[A3, fp.StateT[S, R]]) fp.Func1[A1, fp.StateT[S, R]] {
	return Compose2(f1, Compose2(f2, f3))
}

func Compose4[S any, A1 any, A2, A3, A4, R any](f1 fp.Func1[A1, fp.StateT[S, A2]], f2 fp.Func1[A2, fp.StateT[S, A3]], f3 fp.Func1[A3, fp.StateT[S, A4]], f4 fp.Func1[A4, fp.StateT[S, R]]) fp.Func1[A1, fp.StateT[S, R]] {
	return Compose2(f1, Compose3(f2, f3, f4))
}

func Compose5[S any, A1 any, A2, A3, A4, A5, R any](f1 fp.Func1[A1, fp.StateT[S, A2]], f2 fp.Func1[A2, fp.StateT[S, A3]], f3 fp.Func1[A3, fp.StateT[S, A4]], f4 fp.Func1[A4, fp.StateT[S, A5]], f5 fp.Func1[A5, fp.StateT[S, R]]) fp.Func1[A1, fp.StateT[S, R]] {
	return Compose2(f1, Compose4(f2, f3, f4, f5))
}
