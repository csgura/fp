// Code generated by monad_gen, DO NOT EDIT.
package ptr

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/iterator"
)

func Traverse[A any, R any](ia fp.Iterator[A], fn func(A) fp.Ptr[R]) fp.Ptr[fp.Iterator[R]] {
	return Map(FoldM(ia, fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.Ptr[fp.Seq[R]] {
		return Map(fn(a), acc.Add)
	}), iterator.FromSeq)
}

func TraverseSeq[A any, R any](sa fp.Seq[A], fa func(A) fp.Ptr[R]) fp.Ptr[fp.Seq[R]] {
	return FoldM(fp.IteratorOfSeq(sa), fp.Seq[R]{}, func(acc fp.Seq[R], a A) fp.Ptr[fp.Seq[R]] {
		return Map(fa(a), acc.Add)
	})
}

func TraverseSlice[A any, R any](sa []A, fa func(A) fp.Ptr[R]) fp.Ptr[[]R] {
	return Map(TraverseSeq(sa, fa), fp.Seq[R].Widen)
}

func TraverseFunc[A any, R any](far func(A) fp.Ptr[R]) func(fp.Iterator[A]) fp.Ptr[fp.Iterator[R]] {
	return func(iterA fp.Iterator[A]) fp.Ptr[fp.Iterator[R]] {
		return Traverse(iterA, far)
	}
}

func TraverseSeqFunc[A any, R any](far func(A) fp.Ptr[R]) func(fp.Seq[A]) fp.Ptr[fp.Seq[R]] {
	return func(seqA fp.Seq[A]) fp.Ptr[fp.Seq[R]] {
		return TraverseSeq(seqA, far)
	}
}

func TraverseSliceFunc[A any, R any](far func(A) fp.Ptr[R]) func([]A) fp.Ptr[[]R] {
	return func(seqA []A) fp.Ptr[[]R] {
		return TraverseSlice(seqA, far)
	}
}

func FlatMapTraverseSeq[A any, B any](ta fp.Ptr[fp.Seq[A]], f func(v A) fp.Ptr[B]) fp.Ptr[fp.Seq[B]] {
	return FlatMap(ta, TraverseSeqFunc(f))
}

func FlatMapTraverseSlice[A any, B any](ta fp.Ptr[[]A], f func(v A) fp.Ptr[B]) fp.Ptr[[]B] {
	return FlatMap(ta, TraverseSliceFunc(f))
}

func Sequence[A any](tsa []fp.Ptr[A]) fp.Ptr[[]A] {
	ret := FoldM(iterator.FromSeq(tsa), fp.Seq[A]{}, func(t1 fp.Seq[A], t2 fp.Ptr[A]) fp.Ptr[fp.Seq[A]] {
		return Map(t2, t1.Add)
	})

	return Map(ret, fp.Seq[A].Widen)
}

func SequenceIterator[A any](ita fp.Iterator[fp.Ptr[A]]) fp.Ptr[fp.Iterator[A]] {
	ret := FoldM(ita, fp.Seq[A]{}, func(t1 fp.Seq[A], t2 fp.Ptr[A]) fp.Ptr[fp.Seq[A]] {
		return Map(t2, t1.Add)
	})
	return Map(ret, iterator.FromSeq)

}
