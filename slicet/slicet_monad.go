// Code generated by monad_gen, DO NOT EDIT.
package slicet

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/curried"
	"github.com/csgura/fp/iterator"
	"github.com/csgura/fp/product"
	"github.com/csgura/fp/xtr"
)

func Flatten[A any](tta fp.SliceT[fp.SliceT[A]]) fp.SliceT[A] {
	return FlatMap(tta, func(v fp.SliceT[A]) fp.SliceT[A] {
		return v
	})
}

// haskell 의 <$
// map . const 와 같은 함수
func Replace[A any, R any](s fp.SliceT[A], b R) fp.SliceT[R] {
	return Map(s, fp.Const[A](b))
}

func Map2[A any, B, R any](first fp.SliceT[A], second fp.SliceT[B], fab func(A, B) R) fp.SliceT[R] {
	return FlatMap(first, func(a A) fp.SliceT[R] {
		return Map(second, func(b B) R {
			return fab(a, b)
		})
	})
}

func Zip[A any, B any](first fp.SliceT[A], second fp.SliceT[B]) fp.SliceT[fp.Tuple2[A, B]] {
	return Map2(first, second, product.Tuple2)
}

func Ap[A any, B any](tfab fp.SliceT[fp.Func1[A, B]], ta fp.SliceT[A]) fp.SliceT[B] {
	return FlatMap(tfab, func(fab fp.Func1[A, B]) fp.SliceT[B] {
		return Map(ta, fab)
	})
}

func Compose[A any, B, C any](f1 func(A) fp.SliceT[B], f2 func(B) fp.SliceT[C]) func(A) fp.SliceT[C] {
	return func(a A) fp.SliceT[C] {
		return FlatMap(f1(a), f2)
	}
}

func Compose2[A any, B, C any](f1 func(A) fp.SliceT[B], f2 func(B) fp.SliceT[C]) func(A) fp.SliceT[C] {
	return func(a A) fp.SliceT[C] {
		return FlatMap(f1(a), f2)
	}
}

func ApFunc[A any, B any](tfab fp.SliceT[fp.Func1[A, B]], ta func() fp.SliceT[A]) fp.SliceT[B] {
	return FlatMap(tfab, func(fab fp.Func1[A, B]) fp.SliceT[B] {
		return Map(ta(), fab)
	})
}

// Map(ta , seq.Lift(f)) 와 동일
func MapSeqLift[A any, B any](ta fp.SliceT[fp.Seq[A]], f func(v A) B) fp.SliceT[fp.Seq[B]] {

	return Map(ta, func(a fp.Seq[A]) fp.Seq[B] {
		return iterator.Map(iterator.FromSeq(a), f).ToSeq()
	})
}

// Map(ta , seq.Lift(f)) 와 동일
func MapSliceLift[A any, B any](ta fp.SliceT[[]A], f func(v A) B) fp.SliceT[[]B] {

	return Map(ta, func(a []A) []B {
		return iterator.Map(iterator.FromSeq(a), f).ToSeq()
	})
}

func Lift[A any, R any](fa func(v A) R) func(fp.SliceT[A]) fp.SliceT[R] {
	return func(ta fp.SliceT[A]) fp.SliceT[R] {
		return Map(ta, fa)
	}
}

func LiftA2[A any, B, R any](fab func(A, B) R) func(fp.SliceT[A], fp.SliceT[B]) fp.SliceT[R] {
	return func(a fp.SliceT[A], b fp.SliceT[B]) fp.SliceT[R] {
		return Map2(a, b, fab)
	}
}

func LiftM[A any, R any](fa func(v A) fp.SliceT[R]) func(fp.SliceT[A]) fp.SliceT[R] {
	return func(ta fp.SliceT[A]) fp.SliceT[R] {
		return Flatten(Map(ta, fa))
	}
}

// (a -> b -> m r) -> m a -> m b -> m r
// 하스켈에서는  liftM2 와 liftA2 는 같은 함수이고
// 위와 같은 함수는 존재하지 않음.
// hoogle 에서 검색해 보면 , liftJoin2 , bindM2 등의 이름으로 정의된 것이 있음.
// 하지만 ,  fp 패키지에서도   LiftA2 와 LiftM2 를 동일하게 하는 것은 낭비이고
// M 은 Monad 라는 뜻인데, Monad는 Flatten, FlatMap 의 의미가 있으니까
// LiftM2 를 다음과 같이 정의함.
func LiftM2[A any, B, R any](fab func(A, B) fp.SliceT[R]) func(fp.SliceT[A], fp.SliceT[B]) fp.SliceT[R] {
	return func(a fp.SliceT[A], b fp.SliceT[B]) fp.SliceT[R] {
		return Flatten(Map2(a, b, fab))
	}
}

func FlatMap2[A any, B, R any](first fp.SliceT[A], second fp.SliceT[B], fab func(A, B) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM2(fab)(first, second)
}

// 하스켈 : m( a -> r ) -> a -> m r
// 스칼라 : M[ A => r ] => A => M[R]
// 하스켈이나 스칼라의 기본 패키지에는 이런 기능을 하는 함수가 없는데,
// hoogle 에서 검색해 보면
// https://hoogle.haskell.org/?hoogle=m%20(%20a%20-%3E%20b)%20-%3E%20a%20-%3E%20m%20b
// ?? 혹은 flap 이라는 이름으로 정의된 함수가 있음
func Flap[A any, R any](tfa fp.SliceT[fp.Func1[A, R]]) func(A) fp.SliceT[R] {
	return func(a A) fp.SliceT[R] {
		return Ap(tfa, Pure(a))
	}
}

// 하스켈 : m( a -> b -> r ) -> a -> b -> m r
func Flap2[A any, B, R any](tfab fp.SliceT[fp.Func1[A, fp.Func1[B, R]]]) fp.Func1[A, fp.Func1[B, fp.SliceT[R]]] {
	return func(a A) fp.Func1[B, fp.SliceT[R]] {
		return Flap(Ap(tfab, Pure(a)))
	}
}

// (a -> b -> r) -> m a -> b -> m r
// Map 호출 후에 Flap 을 호출 한 것
//
// https://hoogle.haskell.org/?hoogle=%28+a+-%3E+b+-%3E++r+%29+-%3E+m+a+-%3E++b+-%3E+m+r+&scope=set%3Astackage
// liftOp 라는 이름으로 정의된 것이 있음
func FlapMap[A any, B, R any](tfab func(A, B) R, a fp.SliceT[A]) func(B) fp.SliceT[R] {
	return Flap(Map(a, curried.Func2(tfab)))
}

// ( a -> b -> m r) -> m a -> b -> m r
//
//	Flatten . FlapMap
//
// https://hoogle.haskell.org/?hoogle=(%20a%20-%3E%20b%20-%3E%20m%20r%20)%20-%3E%20m%20a%20-%3E%20%20b%20-%3E%20m%20r%20
// om , ==<<  이름으로 정의된 것이 있음
func FlatFlapMap[A any, B, R any](fab func(A, B) fp.SliceT[R], ta fp.SliceT[A]) func(B) fp.SliceT[R] {
	return fp.Compose(FlapMap(fab, ta), Flatten[R])
}

// FlatMap 과는 아규먼트 순서가 다른 함수로
// Go 나 Java 에서는 메소드 레퍼런스를 이용하여,  객체내의 메소드를 리턴 타입만 lift 된 형태로 리턴하게 할 수 있음.
// Method 라는 이름보다  Ap 와 비슷한 이름이 좋을 거 같은데
// Ap와 비슷한 이름으로 하기에는 Ap 와 타입이 너무 다름.
func Method1[A any, B, R any](ta fp.SliceT[A], fab func(a A, b B) R) func(B) fp.SliceT[R] {
	return FlapMap(fab, ta)
}

func FlatMethod1[A any, B, R any](ta fp.SliceT[A], fab func(a A, b B) fp.SliceT[R]) func(B) fp.SliceT[R] {
	return FlatFlapMap(fab, ta)
}

func Method2[A any, B, C, R any](ta fp.SliceT[A], fabc func(a A, b B, c C) R) func(B, C) fp.SliceT[R] {

	return curried.Revert2(Flap2(Map(ta, curried.Func3(fabc))))
	// return func(b B, c C) fp.SliceT[R] {
	// 	return Map(a, func(a A) R {
	// 		return cf(a, b, c)
	// 	})
	// }
}

func FlatMethod2[A any, B, C, R any](ta fp.SliceT[A], fabc func(a A, b B, c C) fp.SliceT[R]) func(B, C) fp.SliceT[R] {

	return curried.Revert2(curried.Compose2(Flap2(Map(ta, curried.Func3(fabc))), Flatten[R]))

	// return func(b B, c C) fp.SliceT[R] {
	// 	return FlatMap(ta, func(a A) fp.SliceT[R] {
	// 		return cf(a, b, c)
	// 	})
	// }
}

func UnZip[A any, B any](t fp.SliceT[fp.Tuple2[A, B]]) (fp.SliceT[A], fp.SliceT[B]) {
	return Map(t, xtr.Head), Map(t, xtr.Tail)
}

func Zip3[A any, B, C any](ta fp.SliceT[A], tb fp.SliceT[B], tc fp.SliceT[C]) fp.SliceT[fp.Tuple3[A, B, C]] {
	return LiftA3(product.Tuple3[A, B, C])(ta, tb, tc)
}

// fp.With 의 try 버젼
// fp.With 가 Flip 과 사실상 같은 것처럼
// FlapMap 의 Flip 버젼과 동일
// var b fp.Try[B]
// a := try.Sucesss(A{})
// a.FlatMap( try.With(A.WithB, b))
// 형태로 코딩 가능
func With[A any, B any](withf func(A, B) A, v fp.SliceT[B]) func(A) fp.SliceT[A] {
	return Flap(Map(v, fp.Flip2(withf)))
}

func LiftA3[A1 any, A2, A3, R any](f func(a1 A1, a2 A2, a3 A3) R) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftA2(func(a2 A2, a3 A3) R {
				return f(a1, a2, a3)
			})(ins2, ins3)
		})
	}
}

func LiftA4[A1 any, A2, A3, A4, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4) R) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftA3(func(a2 A2, a3 A3, a4 A4) R {
				return f(a1, a2, a3, a4)
			})(ins2, ins3, ins4)
		})
	}
}

func LiftA5[A1 any, A2, A3, A4, A5, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) R) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftA4(func(a2 A2, a3 A3, a4 A4, a5 A5) R {
				return f(a1, a2, a3, a4, a5)
			})(ins2, ins3, ins4, ins5)
		})
	}
}

func LiftA6[A1 any, A2, A3, A4, A5, A6, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftA5(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R {
				return f(a1, a2, a3, a4, a5, a6)
			})(ins2, ins3, ins4, ins5, ins6)
		})
	}
}

func LiftA7[A1 any, A2, A3, A4, A5, A6, A7, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6], fp.SliceT[A7]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftA6(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R {
				return f(a1, a2, a3, a4, a5, a6, a7)
			})(ins2, ins3, ins4, ins5, ins6, ins7)
		})
	}
}

func LiftA8[A1 any, A2, A3, A4, A5, A6, A7, A8, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6], fp.SliceT[A7], fp.SliceT[A8]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftA7(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R {
				return f(a1, a2, a3, a4, a5, a6, a7, a8)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8)
		})
	}
}

func LiftA9[A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6], fp.SliceT[A7], fp.SliceT[A8], fp.SliceT[A9]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8], ins9 fp.SliceT[A9]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftA8(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R {
				return f(a1, a2, a3, a4, a5, a6, a7, a8, a9)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
		})
	}
}

func Map3[A1 any, A2, A3, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], f func(a1 A1, a2 A2, a3 A3) R) fp.SliceT[R] {
	return LiftA3(f)(ins1, ins2, ins3)
}

func Map4[A1 any, A2, A3, A4, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], f func(a1 A1, a2 A2, a3 A3, a4 A4) R) fp.SliceT[R] {
	return LiftA4(f)(ins1, ins2, ins3, ins4)
}

func Map5[A1 any, A2, A3, A4, A5, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) R) fp.SliceT[R] {
	return LiftA5(f)(ins1, ins2, ins3, ins4, ins5)
}

func Map6[A1 any, A2, A3, A4, A5, A6, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R) fp.SliceT[R] {
	return LiftA6(f)(ins1, ins2, ins3, ins4, ins5, ins6)
}

func Map7[A1 any, A2, A3, A4, A5, A6, A7, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R) fp.SliceT[R] {
	return LiftA7(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7)
}

func Map8[A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R) fp.SliceT[R] {
	return LiftA8(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8)
}

func Map9[A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8], ins9 fp.SliceT[A9], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R) fp.SliceT[R] {
	return LiftA9(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
}

func LiftM3[A1 any, A2, A3, R any](f func(a1 A1, a2 A2, a3 A3) fp.SliceT[R]) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftM2(func(a2 A2, a3 A3) fp.SliceT[R] {
				return f(a1, a2, a3)
			})(ins2, ins3)
		})
	}
}

func LiftM4[A1 any, A2, A3, A4, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4) fp.SliceT[R]) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftM3(func(a2 A2, a3 A3, a4 A4) fp.SliceT[R] {
				return f(a1, a2, a3, a4)
			})(ins2, ins3, ins4)
		})
	}
}

func LiftM5[A1 any, A2, A3, A4, A5, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) fp.SliceT[R]) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftM4(func(a2 A2, a3 A3, a4 A4, a5 A5) fp.SliceT[R] {
				return f(a1, a2, a3, a4, a5)
			})(ins2, ins3, ins4, ins5)
		})
	}
}

func LiftM6[A1 any, A2, A3, A4, A5, A6, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.SliceT[R]) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftM5(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.SliceT[R] {
				return f(a1, a2, a3, a4, a5, a6)
			})(ins2, ins3, ins4, ins5, ins6)
		})
	}
}

func LiftM7[A1 any, A2, A3, A4, A5, A6, A7, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.SliceT[R]) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6], fp.SliceT[A7]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftM6(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.SliceT[R] {
				return f(a1, a2, a3, a4, a5, a6, a7)
			})(ins2, ins3, ins4, ins5, ins6, ins7)
		})
	}
}

func LiftM8[A1 any, A2, A3, A4, A5, A6, A7, A8, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.SliceT[R]) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6], fp.SliceT[A7], fp.SliceT[A8]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftM7(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.SliceT[R] {
				return f(a1, a2, a3, a4, a5, a6, a7, a8)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8)
		})
	}
}

func LiftM9[A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.SliceT[R]) func(fp.SliceT[A1], fp.SliceT[A2], fp.SliceT[A3], fp.SliceT[A4], fp.SliceT[A5], fp.SliceT[A6], fp.SliceT[A7], fp.SliceT[A8], fp.SliceT[A9]) fp.SliceT[R] {
	return func(ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8], ins9 fp.SliceT[A9]) fp.SliceT[R] {

		return FlatMap(ins1, func(a1 A1) fp.SliceT[R] {
			return LiftM8(func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.SliceT[R] {
				return f(a1, a2, a3, a4, a5, a6, a7, a8, a9)
			})(ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
		})
	}
}

func FlatMap3[A1 any, A2, A3, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], f func(a1 A1, a2 A2, a3 A3) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM3(f)(ins1, ins2, ins3)
}

func FlatMap4[A1 any, A2, A3, A4, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], f func(a1 A1, a2 A2, a3 A3, a4 A4) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM4(f)(ins1, ins2, ins3, ins4)
}

func FlatMap5[A1 any, A2, A3, A4, A5, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM5(f)(ins1, ins2, ins3, ins4, ins5)
}

func FlatMap6[A1 any, A2, A3, A4, A5, A6, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM6(f)(ins1, ins2, ins3, ins4, ins5, ins6)
}

func FlatMap7[A1 any, A2, A3, A4, A5, A6, A7, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM7(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7)
}

func FlatMap8[A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM8(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8)
}

func FlatMap9[A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ins1 fp.SliceT[A1], ins2 fp.SliceT[A2], ins3 fp.SliceT[A3], ins4 fp.SliceT[A4], ins5 fp.SliceT[A5], ins6 fp.SliceT[A6], ins7 fp.SliceT[A7], ins8 fp.SliceT[A8], ins9 fp.SliceT[A9], f func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.SliceT[R]) fp.SliceT[R] {
	return LiftM9(f)(ins1, ins2, ins3, ins4, ins5, ins6, ins7, ins8, ins9)
}

func Flap3[A1 any, A2, A3, R any](tf fp.SliceT[fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, R]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.SliceT[R]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.SliceT[R]]] {
		return Flap2(Ap(tf, Pure(a1)))
	}
}

func Flap4[A1 any, A2, A3, A4, R any](tf fp.SliceT[fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, R]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.SliceT[R]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.SliceT[R]]]] {
		return Flap3(Ap(tf, Pure(a1)))
	}
}

func Flap5[A1 any, A2, A3, A4, A5, R any](tf fp.SliceT[fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, R]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.SliceT[R]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.SliceT[R]]]]] {
		return Flap4(Ap(tf, Pure(a1)))
	}
}

func Flap6[A1 any, A2, A3, A4, A5, A6, R any](tf fp.SliceT[fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, R]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.SliceT[R]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.SliceT[R]]]]]] {
		return Flap5(Ap(tf, Pure(a1)))
	}
}

func Flap7[A1 any, A2, A3, A4, A5, A6, A7, R any](tf fp.SliceT[fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, R]]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.SliceT[R]]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.SliceT[R]]]]]]] {
		return Flap6(Ap(tf, Pure(a1)))
	}
}

func Flap8[A1 any, A2, A3, A4, A5, A6, A7, A8, R any](tf fp.SliceT[fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, R]]]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.SliceT[R]]]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.SliceT[R]]]]]]]] {
		return Flap7(Ap(tf, Pure(a1)))
	}
}

func Flap9[A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](tf fp.SliceT[fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.Func1[A9, R]]]]]]]]]]) fp.Func1[A1, fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.Func1[A9, fp.SliceT[R]]]]]]]]]] {
	return func(a1 A1) fp.Func1[A2, fp.Func1[A3, fp.Func1[A4, fp.Func1[A5, fp.Func1[A6, fp.Func1[A7, fp.Func1[A8, fp.Func1[A9, fp.SliceT[R]]]]]]]]] {
		return Flap8(Ap(tf, Pure(a1)))
	}
}

func Method3[A1 any, A2, A3, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3) R) func(A2, A3) fp.SliceT[R] {
	return func(a2 A2, a3 A3) fp.SliceT[R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3)
		})
	}
}

func Method4[A1 any, A2, A3, A4, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4) R) func(A2, A3, A4) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4) fp.SliceT[R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4)
		})
	}
}

func Method5[A1 any, A2, A3, A4, A5, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) R) func(A2, A3, A4, A5) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5) fp.SliceT[R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5)
		})
	}
}

func Method6[A1 any, A2, A3, A4, A5, A6, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) R) func(A2, A3, A4, A5, A6) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.SliceT[R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6)
		})
	}
}

func Method7[A1 any, A2, A3, A4, A5, A6, A7, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) R) func(A2, A3, A4, A5, A6, A7) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.SliceT[R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6, a7)
		})
	}
}

func Method8[A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) R) func(A2, A3, A4, A5, A6, A7, A8) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.SliceT[R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
}

func Method9[A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) R) func(A2, A3, A4, A5, A6, A7, A8, A9) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.SliceT[R] {
		return Map(ta1, func(a1 A1) R {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
}

func FlatMethod3[A1 any, A2, A3, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3) fp.SliceT[R]) func(A2, A3) fp.SliceT[R] {
	return func(a2 A2, a3 A3) fp.SliceT[R] {
		return FlatMap(ta1, func(a1 A1) fp.SliceT[R] {
			return fa1(a1, a2, a3)
		})
	}
}

func FlatMethod4[A1 any, A2, A3, A4, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4) fp.SliceT[R]) func(A2, A3, A4) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4) fp.SliceT[R] {
		return FlatMap(ta1, func(a1 A1) fp.SliceT[R] {
			return fa1(a1, a2, a3, a4)
		})
	}
}

func FlatMethod5[A1 any, A2, A3, A4, A5, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5) fp.SliceT[R]) func(A2, A3, A4, A5) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5) fp.SliceT[R] {
		return FlatMap(ta1, func(a1 A1) fp.SliceT[R] {
			return fa1(a1, a2, a3, a4, a5)
		})
	}
}

func FlatMethod6[A1 any, A2, A3, A4, A5, A6, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.SliceT[R]) func(A2, A3, A4, A5, A6) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6) fp.SliceT[R] {
		return FlatMap(ta1, func(a1 A1) fp.SliceT[R] {
			return fa1(a1, a2, a3, a4, a5, a6)
		})
	}
}

func FlatMethod7[A1 any, A2, A3, A4, A5, A6, A7, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.SliceT[R]) func(A2, A3, A4, A5, A6, A7) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7) fp.SliceT[R] {
		return FlatMap(ta1, func(a1 A1) fp.SliceT[R] {
			return fa1(a1, a2, a3, a4, a5, a6, a7)
		})
	}
}

func FlatMethod8[A1 any, A2, A3, A4, A5, A6, A7, A8, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.SliceT[R]) func(A2, A3, A4, A5, A6, A7, A8) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8) fp.SliceT[R] {
		return FlatMap(ta1, func(a1 A1) fp.SliceT[R] {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8)
		})
	}
}

func FlatMethod9[A1 any, A2, A3, A4, A5, A6, A7, A8, A9, R any](ta1 fp.SliceT[A1], fa1 func(a1 A1, a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.SliceT[R]) func(A2, A3, A4, A5, A6, A7, A8, A9) fp.SliceT[R] {
	return func(a2 A2, a3 A3, a4 A4, a5 A5, a6 A6, a7 A7, a8 A8, a9 A9) fp.SliceT[R] {
		return FlatMap(ta1, func(a1 A1) fp.SliceT[R] {
			return fa1(a1, a2, a3, a4, a5, a6, a7, a8, a9)
		})
	}
}

func Compose3[A1 any, A2, A3, R any](f1 fp.Func1[A1, fp.SliceT[A2]], f2 fp.Func1[A2, fp.SliceT[A3]], f3 fp.Func1[A3, fp.SliceT[R]]) fp.Func1[A1, fp.SliceT[R]] {
	return Compose2(f1, Compose2(f2, f3))
}

func Compose4[A1 any, A2, A3, A4, R any](f1 fp.Func1[A1, fp.SliceT[A2]], f2 fp.Func1[A2, fp.SliceT[A3]], f3 fp.Func1[A3, fp.SliceT[A4]], f4 fp.Func1[A4, fp.SliceT[R]]) fp.Func1[A1, fp.SliceT[R]] {
	return Compose2(f1, Compose3(f2, f3, f4))
}

func Compose5[A1 any, A2, A3, A4, A5, R any](f1 fp.Func1[A1, fp.SliceT[A2]], f2 fp.Func1[A2, fp.SliceT[A3]], f3 fp.Func1[A3, fp.SliceT[A4]], f4 fp.Func1[A4, fp.SliceT[A5]], f5 fp.Func1[A5, fp.SliceT[R]]) fp.Func1[A1, fp.SliceT[R]] {
	return Compose2(f1, Compose4(f2, f3, f4, f5))
}

func MapCompose2[A1 any, A2, R any](m fp.SliceT[A1], f1 fp.Func1[A1, A2], f2 fp.Func1[A2, R]) fp.SliceT[R] {
	return Map(m, fp.Compose2(f1, f2))
}

func MapCompose3[A1 any, A2, A3, R any](m fp.SliceT[A1], f1 fp.Func1[A1, A2], f2 fp.Func1[A2, A3], f3 fp.Func1[A3, R]) fp.SliceT[R] {
	return Map(m, fp.Compose3(f1, f2, f3))
}

func MapCompose4[A1 any, A2, A3, A4, R any](m fp.SliceT[A1], f1 fp.Func1[A1, A2], f2 fp.Func1[A2, A3], f3 fp.Func1[A3, A4], f4 fp.Func1[A4, R]) fp.SliceT[R] {
	return Map(m, fp.Compose4(f1, f2, f3, f4))
}

func MapCompose5[A1 any, A2, A3, A4, A5, R any](m fp.SliceT[A1], f1 fp.Func1[A1, A2], f2 fp.Func1[A2, A3], f3 fp.Func1[A3, A4], f4 fp.Func1[A4, A5], f5 fp.Func1[A5, R]) fp.SliceT[R] {
	return Map(m, fp.Compose5(f1, f2, f3, f4, f5))
}

func FlatMapCompose2[A1 any, A2, R any](m fp.SliceT[A1], f1 fp.Func1[A1, fp.SliceT[A2]], f2 fp.Func1[A2, fp.SliceT[R]]) fp.SliceT[R] {
	return FlatMap(m, Compose2(f1, f2))
}

func FlatMapCompose3[A1 any, A2, A3, R any](m fp.SliceT[A1], f1 fp.Func1[A1, fp.SliceT[A2]], f2 fp.Func1[A2, fp.SliceT[A3]], f3 fp.Func1[A3, fp.SliceT[R]]) fp.SliceT[R] {
	return FlatMap(m, Compose3(f1, f2, f3))
}

func FlatMapCompose4[A1 any, A2, A3, A4, R any](m fp.SliceT[A1], f1 fp.Func1[A1, fp.SliceT[A2]], f2 fp.Func1[A2, fp.SliceT[A3]], f3 fp.Func1[A3, fp.SliceT[A4]], f4 fp.Func1[A4, fp.SliceT[R]]) fp.SliceT[R] {
	return FlatMap(m, Compose4(f1, f2, f3, f4))
}

func FlatMapCompose5[A1 any, A2, A3, A4, A5, R any](m fp.SliceT[A1], f1 fp.Func1[A1, fp.SliceT[A2]], f2 fp.Func1[A2, fp.SliceT[A3]], f3 fp.Func1[A3, fp.SliceT[A4]], f4 fp.Func1[A4, fp.SliceT[A5]], f5 fp.Func1[A5, fp.SliceT[R]]) fp.SliceT[R] {
	return FlatMap(m, Compose5(f1, f2, f3, f4, f5))
}
