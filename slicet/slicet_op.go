// Code generated by monad_gen, DO NOT EDIT.
package slicet

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/iterator"
	"github.com/csgura/fp/slice"
	"github.com/csgura/fp/try"
)

func Pure[A any](a A) fp.SliceT[A] {
	return try.Success[fp.Slice[A]](slice.Pure[A](a))
}

func LiftT[A any](a fp.Try[A]) fp.SliceT[A] {
	return try.Map(a, slice.Pure[A])
}

func Map[A any, B any](t fp.SliceT[A], f func(A) B) fp.SliceT[B] {
	return try.Map(t, func(ma fp.Slice[A]) fp.Slice[B] {
		return slice.FlatMap[A, B](ma, func(a A) fp.Slice[B] {
			return slice.Pure[B](f(a))
		})
	})
}

func SubFlatMap[A any, B any](t fp.SliceT[A], f func(A) fp.Slice[B]) fp.SliceT[B] {
	return try.Map(t, func(ma fp.Slice[A]) fp.Slice[B] {
		return slice.FlatMap[A, B](ma, func(a A) fp.Slice[B] {
			return f(a)
		})
	})
}

func MapT[A any, B any](t fp.SliceT[A], f func(A) fp.Try[B]) fp.SliceT[B] {
	sequencef := func(v fp.Slice[fp.Try[B]]) fp.SliceT[B] {
		return try.FoldM(iterator.FromSeq(v), fp.Slice[B]{}, func(t1 fp.Slice[B], t2 fp.Try[B]) fp.SliceT[B] {
			return try.Map(t2, func(v B) fp.Slice[B] {
				return append(t1, v)
			})
		})
	}
	return try.FlatMap(Map(t, f), sequencef)
}

func FlatMap[A any, B any](t fp.SliceT[A], f func(A) fp.SliceT[B]) fp.SliceT[B] {

	flatten := func(v fp.Slice[fp.Slice[B]]) fp.Slice[B] {
		return slice.FlatMap[fp.Slice[B], B](v, fp.Id)
	}

	return try.Map(MapT(t, f), flatten)

}

func Filter[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Filter[T](insideValue, p)
	})
}

func Add[T any](sliceT fp.SliceT[T], item T) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Add[T](insideValue, item)
	})
}

func Append[T any](sliceT fp.SliceT[T], items T) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Append[T](insideValue, items)
	})
}

func Concat[T any](sliceT fp.SliceT[T], tail fp.Slice[T]) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Concat[T](insideValue, tail)
	})
}

func Drop[T any](sliceT fp.SliceT[T], n int) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Drop[T](insideValue, n)
	})
}

func Exists[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.Exists[T](insideValue, p)
	})
}

func FilterNot[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.FilterNot[T](insideValue, p)
	})
}

func Find[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Find[T](insideValue, p)
	})
}

func ForAll[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.ForAll[T](insideValue, p)
	})
}

func Foreach[T any](sliceT fp.SliceT[T], f func(v T)) {
	try.Map(sliceT, func(insideValue fp.Slice[T]) error {
		slice.Foreach[T](insideValue, f)
		return nil
	})
}

func Get[T any](sliceT fp.SliceT[T], idx int) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Get[T](insideValue, idx)
	})
}

func Head[T any](sliceT fp.SliceT[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Head[T](insideValue)
	})
}

func Tail[T any](sliceT fp.SliceT[T]) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Tail[T](insideValue)
	})
}

func Init[T any](sliceT fp.SliceT[T]) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Init[T](insideValue)
	})
}

func IsEmpty[T any](sliceT fp.SliceT[T]) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.IsEmpty[T](insideValue)
	})
}

func Last[T any](sliceT fp.SliceT[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Last[T](insideValue)
	})
}

func MakeString[T any](sliceT fp.SliceT[T], sep string) fp.Try[string] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) string {
		return slice.MakeString[T](insideValue, sep)
	})
}

func NonEmpty[T any](sliceT fp.SliceT[T]) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.NonEmpty[T](insideValue)
	})
}

func Reverse[T any](sliceT fp.SliceT[T]) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Reverse[T](insideValue)
	})
}

func Size[T any](sliceT fp.SliceT[T]) fp.Try[int] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) int {
		return slice.Size[T](insideValue)
	})
}

func Take[T any](sliceT fp.SliceT[T], n int) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Take[T](insideValue, n)
	})
}

func Fold[T any, U any](sliceT fp.SliceT[T], zero U, f func(U, T) U) fp.Try[U] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) U {
		return slice.Fold[T, U](insideValue, zero, f)
	})
}

func Scan[T any, U any](sliceT fp.SliceT[T], zero U, f func(U, T) U) fp.Try[fp.Slice[U]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[U] {
		return slice.Scan[T, U](insideValue, zero, f)
	})
}

func Sort[T any](sliceT fp.SliceT[T], ord fp.Ord[T]) fp.Try[fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Sort[T](insideValue, ord)
	})
}

func Min[T any](sliceT fp.SliceT[T], ord fp.Ord[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Min[T](insideValue, ord)
	})
}

func Max[T any](sliceT fp.SliceT[T], ord fp.Ord[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Max[T](insideValue, ord)
	})
}

func FilterMap[T any, U any](sliceT fp.SliceT[T], fn func(v T) fp.Option[U]) fp.Try[fp.Slice[U]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[U] {
		return slice.FilterMap[T, U](insideValue, fn)
	})
}
