// Code generated by monad_gen, DO NOT EDIT.
package slicet

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
	"github.com/csgura/fp/iterator"
	"github.com/csgura/fp/mutable"
	"github.com/csgura/fp/slice"
	"github.com/csgura/fp/try"
)

func Pure[A any](a A) fp.SliceT[A] {
	return try.Success[fp.Slice[A]](slice.Pure[A](a))
}

func LiftT[A any](a fp.Try[A]) fp.SliceT[A] {
	return try.Map(a, slice.Pure[A])
}

func Map[A any, B any](t fp.SliceT[A], f func(A) B) fp.SliceT[B] {
	return try.Map(t, func(ma fp.Slice[A]) fp.Slice[B] {
		return slice.FlatMap[A, B](ma, func(a A) fp.Slice[B] {
			return slice.Pure[B](f(a))
		})
	})
}

func SubFlatMap[A any, B any](t fp.SliceT[A], f func(A) fp.Slice[B]) fp.SliceT[B] {
	return try.Map(t, func(ma fp.Slice[A]) fp.Slice[B] {
		return slice.FlatMap[A, B](ma, func(a A) fp.Slice[B] {
			return f(a)
		})
	})
}

func MapT[A any, B any](t fp.SliceT[A], f func(A) fp.Try[B]) fp.SliceT[B] {
	sequencef := func(v fp.Slice[fp.Try[B]]) fp.SliceT[B] {
		return try.FoldM(iterator.FromSeq(v), fp.Slice[B]{}, func(t1 fp.Slice[B], t2 fp.Try[B]) fp.SliceT[B] {
			return try.Map(t2, func(v B) fp.Slice[B] {
				return append(t1, v)
			})
		})
	}
	return try.FlatMap(Map(t, f), sequencef)
}

func FlatMap[A any, B any](t fp.SliceT[A], f func(A) fp.SliceT[B]) fp.SliceT[B] {

	flatten := func(v fp.Slice[fp.Slice[B]]) fp.Slice[B] {
		return slice.FlatMap[fp.Slice[B], B](v, fp.Id)
	}

	return try.Map(MapT(t, f), flatten)

}

func Filter[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Filter[T](insideValue, p)
	})
}

func Add[T any](sliceT fp.SliceT[T], item T) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Add[T](insideValue, item)
	})
}

func Append[T any](sliceT fp.SliceT[T], items T) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Append[T](insideValue, items)
	})
}

func Prepend[T any](head T, sliceT fp.SliceT[T]) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Prepend[T](head, insideValue)
	})
}

func Concat[T any](sliceT fp.SliceT[T], tail fp.Slice[T]) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Concat[T](insideValue, tail)
	})
}

func Drop[T any](sliceT fp.SliceT[T], n int) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Drop[T](insideValue, n)
	})
}

func Exists[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.Exists[T](insideValue, p)
	})
}

func FilterNot[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.FilterNot[T](insideValue, p)
	})
}

func Find[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Find[T](insideValue, p)
	})
}

func ForAll[T any](sliceT fp.SliceT[T], p func(v T) bool) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.ForAll[T](insideValue, p)
	})
}

func Get[T any](sliceT fp.SliceT[T], idx int) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Get[T](insideValue, idx)
	})
}

func Head[T any](sliceT fp.SliceT[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Head[T](insideValue)
	})
}

func Tail[T any](sliceT fp.SliceT[T]) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Tail[T](insideValue)
	})
}

func Init[T any](sliceT fp.SliceT[T]) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Init[T](insideValue)
	})
}

func IsEmpty[T any](sliceT fp.SliceT[T]) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.IsEmpty[T](insideValue)
	})
}

func Last[T any](sliceT fp.SliceT[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Last[T](insideValue)
	})
}

func MakeString[T any](sliceT fp.SliceT[T], sep string) fp.Try[string] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) string {
		return slice.MakeString[T](insideValue, sep)
	})
}

func NonEmpty[T any](sliceT fp.SliceT[T]) fp.Try[bool] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) bool {
		return slice.NonEmpty[T](insideValue)
	})
}

func Reverse[T any](sliceT fp.SliceT[T]) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Reverse[T](insideValue)
	})
}

func Size[T any](sliceT fp.SliceT[T]) fp.Try[int] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) int {
		return slice.Size[T](insideValue)
	})
}

func Take[T any](sliceT fp.SliceT[T], n int) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Take[T](insideValue, n)
	})
}

func Span[T any](sliceT fp.SliceT[T], p func(T) bool) fp.Try[fp.Tuple2[fp.Slice[T], fp.Slice[T]]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Tuple2[fp.Slice[T], fp.Slice[T]] {
		return as.Tuple2(slice.Span[T](insideValue, p))
	})
}

func Partition[T any](sliceT fp.SliceT[T], p func(T) bool) fp.Try[fp.Tuple2[fp.Slice[T], fp.Slice[T]]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Tuple2[fp.Slice[T], fp.Slice[T]] {
		return as.Tuple2(slice.Partition[T](insideValue, p))
	})
}

func FilterMap[T any, U any](sliceT fp.SliceT[T], fn func(v T) fp.Option[U]) fp.SliceT[U] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[U] {
		return slice.FilterMap[T, U](insideValue, fn)
	})
}

func Fold[T any, U any](sliceT fp.SliceT[T], zero U, f func(U, T) U) fp.Try[U] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) U {
		return slice.Fold[T, U](insideValue, zero, f)
	})
}

func Scan[T any, U any](sliceT fp.SliceT[T], zero U, f func(U, T) U) fp.SliceT[U] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[U] {
		return slice.Scan[T, U](insideValue, zero, f)
	})
}

func Sort[T any](sliceT fp.SliceT[T], ord fp.Ord[T]) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[T] {
		return slice.Sort[T](insideValue, ord)
	})
}

func Min[T any](sliceT fp.SliceT[T], ord fp.Ord[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Min[T](insideValue, ord)
	})
}

func Max[T any](sliceT fp.SliceT[T], ord fp.Ord[T]) fp.Try[fp.Option[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Option[T] {
		return slice.Max[T](insideValue, ord)
	})
}

func FoldTry[T any, U any](sliceT fp.SliceT[T], zero U, f func(U, T) fp.Try[U]) fp.Try[U] {
	return try.FlatMap(sliceT, func(insideValue fp.Slice[T]) fp.Try[U] {
		return slice.FoldTry[T, U](insideValue, zero, f)
	})
}

func FoldError[T any](sliceT fp.SliceT[T], f func(T) error) fp.Try[error] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) error {
		return slice.FoldError[T](insideValue, f)
	})
}

func Reduce[T any](sliceT fp.SliceT[T], m fp.Monoid[T]) fp.Try[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) T {
		return slice.Reduce[T](insideValue, m)
	})
}

func Distinct[K comparable](sliceT fp.SliceT[K]) fp.SliceT[K] {
	return try.Map(sliceT, func(insideValue fp.Slice[K]) fp.Slice[K] {
		return slice.Distinct[K](insideValue)
	})
}

func ToGoMap[K comparable, V any](sliceT fp.SliceT[fp.Tuple2[K, V]]) fp.Try[map[K]V] {
	return try.Map(sliceT, func(insideValue fp.Slice[fp.Tuple2[K, V]]) map[K]V {
		return slice.ToGoMap[K, V](insideValue)
	})
}

func ToGoSet[K comparable](sliceT fp.SliceT[K]) fp.Try[mutable.Set[K]] {
	return try.Map(sliceT, func(insideValue fp.Slice[K]) mutable.Set[K] {
		return slice.ToGoSet[K](insideValue)
	})
}

func ToMap[T any, V any](sliceT fp.SliceT[fp.Tuple2[T, V]], hasher fp.Hashable[T]) fp.Try[fp.Map[T, V]] {
	return try.Map(sliceT, func(insideValue fp.Slice[fp.Tuple2[T, V]]) fp.Map[T, V] {
		return slice.ToMap[T, V](insideValue, hasher)
	})
}

func ToSet[T any](sliceT fp.SliceT[T], hasher fp.Hashable[T]) fp.Try[fp.Set[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Set[T] {
		return slice.ToSet[T](insideValue, hasher)
	})
}

func GroupBy[T any, K comparable](sliceT fp.SliceT[T], keyFunc func(T) K) fp.Try[map[K]fp.Slice[T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) map[K]fp.Slice[T] {
		return slice.GroupBy[T, K](insideValue, keyFunc)
	})
}

func Flatten[T any](sliceT fp.SliceT[fp.Slice[T]]) fp.SliceT[T] {
	return try.Map(sliceT, func(insideValue fp.Slice[fp.Slice[T]]) fp.Slice[T] {
		return slice.Flatten[T](insideValue)
	})
}

func ZipWithIndex[T any](sliceT fp.SliceT[T]) fp.SliceT[fp.Tuple2[int, T]] {
	return try.Map(sliceT, func(insideValue fp.Slice[T]) fp.Slice[fp.Tuple2[int, T]] {
		return slice.ZipWithIndex[T](insideValue)
	})
}
