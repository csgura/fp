# github.com/csgura/fp

This package is inspired by Haskell, Scala, Shapeless, and Scala Cats.  
This package provides algebraic data types such as Tuple and Option.

cmd/gombok is a lombok-like code generator that generates getter and builder methods.

# 1. How to run
Install gombok using:

`go install github.com/csgura/fp/cmd/gombok`


# 2. @fp.Value 
```go
package docexample
 
//go:generate gombok
 
// @fp.Value
type Person struct {
    name string
    age  int
}
```

go:generate only needs to be specified once in a package.
 
@fp.Value must be specified to each struct to generate getter method.
 
Getters of fields that start with an uppercase letter will not generated.  
Getters of fields starting with _ also will not generated.
 
Running `go generate` will generate the `packname_value_generated.go` file.

The following types and methods are created in the generated file.

## 2.1. Getter method
```go
func (r Person) Name() string {
    return r.name
}
 
func (r Person) Age() int {
    return r.age
}
 
```

## 2.2. String method
```go
func (r Person) String() string {
    return fmt.Sprintf("Person(name=%v, age=%v)", r.name, r.age)
}
```

## 2.3. With method
```go
func (r Person) WithName(v string) Person {
    r.name = v
    return r
}
 
 
func (r Person) WithAge(v int) Person {
    r.age = v
    return r
}
```

## 2.4 AsTuple method
```go
func (r Person) AsTuple() fp.Tuple2[string, int] {
    return as.Tuple2(r.name, r.age)
}
```

## 2.5. AsMap method
```go
func (r Person) AsMap() map[string]any {
    return map[string]any{
        "name": r.name,
        "age":  r.age,
    }
}
```

## 2.6. Builder type and  conversion method
```go
type PersonBuilder Person
 
 
 
func (r PersonBuilder) Build() Person {
    return Person(r)
}
 
 
func (r PersonBuilder) Name(v string) PersonBuilder {
    r.name = v
    return r
}
 
 
func (r PersonBuilder) Age(v int) PersonBuilder {
    r.age = v
    return r
}
 
func (r PersonBuilder) FromTuple(t fp.Tuple2[string, int]) PersonBuilder {
    r.name = t.I1
    r.age = t.I2
    return r
}
 
 
func (r PersonBuilder) FromMap(m map[string]any) PersonBuilder {
 
    if v, ok := m["name"].(string); ok {
        r.name = v
    }
 
    if v, ok := m["age"].(int); ok {
        r.age = v
    }
 
    return r
}
```

```go
func (r Person) Builder() PersonBuilder {
    return PersonBuilder(r)
}
```

## 2.7. Mutable type and conversion method
```go
type PersonMutable struct {
    Name string
    Age  int
}
 
 
func (r PersonMutable) AsImmutable() Person {
    return Person{
        name: r.Name,
        age:  r.Age,
    }
}
```

```go
func (r Person) AsMutable() PersonMutable {
    return PersonMutable{
        Name: r.name,
        Age:  r.age,
    }
}
```

## 2.8. equals and hashCode method
Unlike lombok,
gombok doesn't generate equals and hashCode methods because they don't need.  
If it required for some other reason,  
You can use an instance of the fp.Eq or fp.Hashable type class which can be genereted by gombok to define equals and hashCode method.
```go
// @fp.Derive
var _ hash.Derives[fp.Hashable[Person]]

// var HashablePerson fp.Hashable[Person] 
// will be generated by above @fp.Derive annotation

// you can define Eq method by calling HasablePerson.Eqv
func (r Person) Eq(other Person) bool {
    return HashablePerson.Eqv(r, other)
}
 
func (r Person) Hashcode() uint32 {
    return HashablePerson.Hash(r)
}
 
```

## 2.9. fp.Option support
```go
// @fp.Value
type User struct {
    name   string
    email  fp.Option[string]
    active bool
}
```
If field type is Option, the following Option-related methods are added.

```go
func (r User) WithSomeEmail(v string) User {
    r.email = option.Some(v)
    return r
}
 
func (r User) WithNoneEmail() User {
    r.email = option.None[string]()
    return r
}
 
 
func (r UserBuilder) SomeEmail(v string) UserBuilder {
    r.email = option.Some(v)
    return r
}
 
func (r UserBuilder) NoneEmail() UserBuilder {
    r.email = option.None[string]()
    return r
}
```

# 3. @fp.Json
```go
// @fp.Value
// @fp.Json
type Address struct {
    country string
    city    string
    street  string
}
```

## 3.1. Json tag of mutable type
```go
type AddressMutable struct {
    Country string `json:"country,omitempty"`
    City    string `json:"city,omitempty"`
    Street  string `json:"street,omitempty"`
}
```

Json tags will be added to the fields of mutable type.  
If the json tag is already defined, it is just copied.

## 3.2. MasharlJSON, UnmarshalJSON 
```go
func (r Address) MarshalJSON() ([]byte, error) {
    m := r.AsMutable()
    return json.Marshal(m)
}
 
func (r *Address) UnmarshalJSON(b []byte) error {
    if r == nil {
        return fp.Error(http.StatusBadRequest, "target ptr is nil")
    }
    m := r.AsMutable()
    err := json.Unmarshal(b, &m)
    if err == nil {
        *r = m.AsImmutable()
    }
    return err
}
```
As above, MarshalJSON and UnmarshalJSON methods are generated.

# 4. @fp.GenLabelled
```go
// @fp.Value
// @fp.GenLabelled
type Car struct {
    company string
    model   string
    year    int
}
```

## 4.1. AsLabelled method
```go
func (r Car) AsLabelled() fp.Labelled3[NameIsCompany[string], NameIsModel[string], NameIsYear[int]] {
    return as.Labelled3(NameIsCompany[string]{r.company}, NameIsModel[string]{r.model}, NameIsYear[int]{r.year})
}
```

## 4.2. FromLabelled method
```go
func (r CarBuilder) FromLabelled(t fp.Labelled3[NameIsCompany[string], NameIsModel[string], NameIsYear[int]]) CarBuilder {
    r.company = t.I1.Value()
    r.model = t.I2.Value()
    r.year = t.I3.Value()
    return r
}
```

## 4.3. Labelled type
```go
type NameIsCompany[T any] fp.Tuple1[T]
 
func (r NameIsCompany[T]) Name() string {
    return "company"
}
func (r NameIsCompany[T]) Value() T {
    return r.I1
}
func (r NameIsCompany[T]) WithValue(v T) NameIsCompany[T] {
    r.I1 = v
    return r
}
```

# 5. Types that have type parameters.
```go
// @fp.Value
type Entry[A comparable, B any] struct {
    key   A
    value B
}
```

```go
type EntryBuilder[A comparable, B any] Entry[A, B]
 
type EntryMutable[A comparable, B any] struct {
    Key   A
    Value B
}
 
func (r Entry[A, B]) Key() A {
    return r.key
}
 
func (r Entry[A, B]) WithKey(v A) Entry[A, B] {
    r.key = v
    return r
}
```

# 6. @fp.Derive
```go
// @fp.Derive
var _ eq.Derives[fp.Eq[Person]]
```
`fp.Eq[Person]` is target type to be generated.

`eq.Derives` means eq package has type class instances of primitive types ( e.g. Tuple, String , HCons , HNil ) , 
and these instances will be used to generate `fp.Eq[Person]`

`eq.Derives` is a phantom type and has no functionality.
```go
package eq
type Derives[T any] interface {
	
}
```

The generated codes is like this:
```go
var EqPerson fp.Eq[Person] = eq.ContraMap(
    eq.Tuple2(eq.String, eq.Given[int]()),
    Person.AsTuple,
)
```

## 6.1. Type class instance naming rule
A type class instance is found by name.  
Here are the rules for names.
| Target <br>Type   | Example        | Local                        | Package of Type | Derive Package                                                  |
|-------------------|----------------|------------------------------|-----------------|-----------------------------------------------------------------|
| Go named type             | `time.Duration`  | `EqTimeDuration`, `EqDuration`    | `time.EqDuration` | `eq.TimeDuration`, `eq.Duration` |
| Tuple ( 1 ~ 21 )  | `Tuple2`       | `EqTuple2[A,B any)(Eq[A], Eq[B])`           |                 | `Tuple2[A,B any)(Eq[A], Eq[B])`              |
| hlist.Cons        | `hlist.Cons`   | `EqHCons[H any,T hlist.HList](Eq[H], Eq[T])` |                 | `eq.HCons[H any,T hlist.HList](Eq[H], Eq[T])` |
| hlist.Nil         | `hlist.Nil`    | `EqHNil`                                     |                 | `eq.HNil`                                     |
| Slice             | `[]string`       | `EqSlice( Eq[string] )`        |                 | `eq.Slice(Eq[string))`                   |
| Map               | `map[string]any` | `EqGoMap(Eq[string], Eq[any])` |                 | `eq.GoMap(Eq[string], Eq[any])` |
| []byte            | `[]byte`         | `EqBytes`, `EqSlice(Eq[byte])`                      |                 |  `eq.Bytes`, `eq.Slice(Eq[byte])`                                           |
| Basic             | `int`            | `EqInt`                        |                 |  `eq.Int`                                               |
| number            | `float64`        | `EqNumber[~float64 \| ~int]()` |                 | `eq.Number[~float64 \| ~int]()` |
| comparable or any | `comparable`     | `EqGiven[comparable]()`        |                 | `eq.Given[comparable]()`               |
| Labelled ( 1 ~ 21 ) | `Labelled2`     | `EqLabelled2[A,B fp.Named)(Eq[A], Eq[B])`         |                 | `eq.Labelled2[A,B fp.Named)(Eq[A], Eq[B])`               |
| hlist.Cons Labelled | `hlist.Cons`     | `EqHConsLabelled[H fp.Named, T hlist.HList)(Eq[H], Eq[T])`         |                 | `eq.HConsLabelled[H fp.Named, T hlist.HList)(Eq[H], Eq[T])`               |
| fp.Named | `fp.Named`     | `EqNamed[T fp.NamedField[A], A any)(Eq[A])`         |                 | `eq.Named[T fp.NamedField[A], A any)(Eq[A])`           |



## 6.2. Type class variant
One of ContraMap, IMap, Map and Generic functions must be provided to convert struct <-> tuple or hlist.
| Type class variant | Function must be provided | Example Type class |
|--------------------|---------------------------|--------------------|
| Covariant          | `Map` or `Generic`            | Decoder, Read      |
| Contravariant      | `ContraMap` or `Generic`      | Eq, Ord, Encoder, Show      |
| Invariant          | `IMap` or `Generic`           | Monoid             |


ContraMap should have the following form.
```go
func ContraMap[T, U any](instance fp.Eq[T], fn func(U) T) fp.Eq[U] {
	return New(func(a, b U) bool {
		return instance.Eqv(fn(a), fn(b))
	})
}
```

Map should have the following form.
```go
func Map[A, B any](aread Read[A], fab func(A) B) Read[B] {
	return New(func(s string) fp.Try[Result[B]] {
		return try.Map(aread.Reads(s), func(r Result[A]) Result[B] {
			return MapResult(r, fab)
		})
	})
}
```

IMap should have the following form.
```go
func IMap[A, B any](instance fp.Monoid[A], fab func(A) B, fba func(B) A) fp.Monoid[B] {
	return New(func() B {
		return fab(instance.Empty())
	}, func(a, b B) B {
		return fab(instance.Combine(fba(a), fba(b)))
	})
}
```

Generic should have the following form.
```go
func Generic[A, Repr any](gen fp.Generic[A, Repr], reprShow fp.Show[Repr]) fp.Show[A] {
	return New(func(a A) string {
		return fmt.Sprintf("%s(%s)", gen.Type, reprShow.Show(gen.To(a)))
	})
}
```

fp.Generic is following type.
```go
package fp

type Generic[T, Repr any] struct {
	Type string
	To   func(T) Repr
	From func(Repr) T
}
```

# 7. @fp.ImportGiven
```go
// @fp.ImportGiven
var _ ord.Derives[fp.Ord[any]]
```

You can import type class instances defined in other packages.

# 8. Type class example
* Show : https://github.com/csgura/fp/blob/master/test/internal/show/show.go
* Read : https://github.com/csgura/fp/blob/master/test/internal/read/read.go
* Json Encoder : https://github.com/csgura/fp/blob/master/test/internal/js/encoder.go
* Json Decoder : https://github.com/csgura/fp/blob/master/test/internal/js/decoder.go
* Eq : https://github.com/csgura/fp/blob/master/eq/eq_op.go
* Ord : https://github.com/csgura/fp/blob/master/ord/ord_op.go
* Monoid : https://github.com/csgura/fp/blob/master/monoid/monoid_op.go
* Hashable : https://github.com/csgura/fp/blob/master/hash/hash_op.go

