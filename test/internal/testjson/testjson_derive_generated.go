// Code generated by gombok, DO NOT EDIT.
package testjson

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
	"github.com/csgura/fp/lazy"
	"github.com/csgura/fp/product"
	"github.com/csgura/fp/test/internal/js"
)

func EncoderRoot() js.Encoder[Root] {
	return js.EncoderContraMap(
		js.EncoderHConsLabelled(
			js.EncoderNamed[NamedA[int], int](js.EncoderNumber[int]()),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NamedB[string], string](js.EncoderString),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NamedC[float64], float64](js.EncoderNumber[float64]()),
					js.EncoderHConsLabelled(
						js.EncoderNamed[NamedD[bool], bool](js.EncoderBool),
						js.EncoderHConsLabelled(
							js.EncoderNamed[NamedE[*int], *int](js.EncoderPtr(lazy.Call(func() js.Encoder[int] {
								return js.EncoderNumber[int]()
							}))),
							js.EncoderHConsLabelled(
								js.EncoderNamed[NamedF[[]int], []int](js.EncoderSlice(js.EncoderNumber[int]())),
								js.EncoderHConsLabelled(
									js.EncoderNamed[NamedG[map[string]int], map[string]int](js.EncoderGoMap(js.EncoderNumber[int]())),
									js.EncoderHConsLabelled(
										js.EncoderNamed[NamedH[Child], Child](EncoderChild()),
										js.EncoderHNil,
									),
								),
							),
						),
					),
				),
			),
		),
		fp.Compose(
			Root.AsLabelled,
			as.HList8Labelled,
		),
	)
}

func DecoderRoot() js.Decoder[Root] {
	return js.DecoderMap(
		js.DecoderHConsLabelled(
			js.DecoderNamed[NamedA[int], int](js.DecoderNumber[int]()),
			js.DecoderHConsLabelled(
				js.DecoderNamed[NamedB[string], string](js.DecoderString),
				js.DecoderHConsLabelled(
					js.DecoderNamed[NamedC[float64], float64](js.DecoderNumber[float64]()),
					js.DecoderHConsLabelled(
						js.DecoderNamed[NamedD[bool], bool](js.DecoderBool),
						js.DecoderHConsLabelled(
							js.DecoderNamed[NamedE[*int], *int](js.DecoderPtr(lazy.Call(func() js.Decoder[int] {
								return js.DecoderNumber[int]()
							}))),
							js.DecoderHConsLabelled(
								js.DecoderNamed[NamedF[[]int], []int](js.DecoderSlice(js.DecoderNumber[int]())),
								js.DecoderHConsLabelled(
									js.DecoderNamed[NamedG[map[string]int], map[string]int](js.DecoderGoMap(js.DecoderNumber[int]())),
									js.DecoderHConsLabelled(
										js.DecoderNamed[NamedH[Child], Child](DecoderChild()),
										js.DecoderHNil,
									),
								),
							),
						),
					),
				),
			),
		),

		fp.Compose(
			product.LabelledFromHList8,
			fp.Compose(
				as.Curried2(RootBuilder.FromLabelled)(RootBuilder{}),
				RootBuilder.Build,
			),
		),
	)
}

func EncoderChild() js.Encoder[Child] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NamedA[map[string]any], map[string]any](js.EncoderGoMapAny), js.EncoderNamed[NamedB[any], any](js.EncoderGiven[any]())),
		Child.AsLabelled,
	)
}

func DecoderChild() js.Decoder[Child] {
	return js.DecoderMap(
		js.DecoderLabelled2(js.DecoderNamed[NamedA[map[string]any], map[string]any](js.DecoderGoMapAny), js.DecoderNamed[NamedB[any], any](js.DecoderGiven[any]())),
		fp.Compose(
			as.Curried2(ChildBuilder.FromLabelled)(ChildBuilder{}),
			ChildBuilder.Build,
		),
	)
}

func EncoderNode() js.Encoder[Node] {
	return js.EncoderContraMap(
		js.EncoderHConsLabelled(
			js.EncoderNamed[NamedName[string], string](js.EncoderString),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NamedLeft[*Node], *Node](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
					return EncoderNode()
				}))),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NamedRight[*Node], *Node](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
						return EncoderNode()
					}))),
					js.EncoderHNil,
				),
			),
		),
		fp.Compose(
			Node.AsLabelled,
			as.HList3Labelled,
		),
	)
}

func EncoderTree() js.Encoder[Tree] {
	return js.EncoderContraMap(
		js.EncoderLabelled1(js.EncoderNamed[NamedRoot[*Node], *Node](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
			return EncoderNode()
		})))),
		Tree.AsLabelled,
	)
}

func EncoderEntry[V any](encoderV js.Encoder[V]) js.Encoder[Entry[V]] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NamedName[string], string](js.EncoderString), js.EncoderNamed[NamedValue[V], V](encoderV)),
		Entry[V].AsLabelled,
	)
}

func EncoderNotUsedParam[K any, V any](encoderV js.Encoder[V]) js.Encoder[NotUsedParam[K, V]] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NamedParam[string], string](js.EncoderString), js.EncoderNamed[NamedValue[V], V](encoderV)),
		NotUsedParam[K, V].AsLabelled,
	)
}

func EncoderMovie() js.Encoder[Movie] {
	return js.EncoderContraMap(
		js.EncoderHConsLabelled(
			js.EncoderNamed[NamedName[string], string](js.EncoderString),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NamedCasting[Entry[string]], Entry[string]](EncoderEntry(js.EncoderString)),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NamedNotUsed[NotUsedParam[int, string]], NotUsedParam[int, string]](EncoderNotUsedParam[int, string](js.EncoderString)),
					js.EncoderHNil,
				),
			),
		),
		fp.Compose(
			Movie.AsLabelled,
			as.HList3Labelled,
		),
	)
}

func EncoderNoPrivate() js.Encoder[NoPrivate] {
	return js.EncoderContraMap(
		js.EncoderLabelled1(js.EncoderNamed[PubNamedRoot[string], string](js.EncoderString)),
		NoPrivate.AsLabelled,
	)
}

func DecoderNoPrivate() js.Decoder[NoPrivate] {
	return js.DecoderMap(
		js.DecoderHConsLabelled(
			js.DecoderNamed[PubNamedRoot[string], string](js.DecoderString),
			js.DecoderHNil,
		),

		fp.Compose(
			product.LabelledFromHList1,
			fp.Compose(
				as.Curried2(NoPrivateBuilder.FromLabelled)(NoPrivateBuilder{}),
				NoPrivateBuilder.Build,
			),
		),
	)
}
