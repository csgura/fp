// Code generated by gombok, DO NOT EDIT.
package testjson

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
	"github.com/csgura/fp/lazy"
	"github.com/csgura/fp/product"
	"github.com/csgura/fp/test/internal/js"
)

var EncoderRoot = js.EncoderContraMap(
	js.EncoderHConsLabelled(
		js.EncoderNamed[NameIsA[int]](js.EncoderNumber[int]()),
		js.EncoderHConsLabelled(
			js.EncoderNamed[NameIsB[string]](js.EncoderString),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NameIsC[float64]](js.EncoderNumber[float64]()),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NameIsD[bool]](js.EncoderBool),
					js.EncoderHConsLabelled(
						js.EncoderNamed[NameIsE[*int]](js.EncoderPtr(lazy.Call(func() js.Encoder[int] {
							return js.EncoderNumber[int]()
						}))),
						js.EncoderHConsLabelled(
							js.EncoderNamed[NameIsF[[]int]](js.EncoderSlice(js.EncoderNumber[int]())),
							js.EncoderHConsLabelled(
								js.EncoderNamed[NameIsG[map[string]int]](js.EncoderGoMap(js.EncoderNumber[int]())),
								js.EncoderHConsLabelled(
									js.EncoderNamed[NameIsH[Child]](EncoderChild),
									js.EncoderHNil,
								),
							),
						),
					),
				),
			),
		),
	),
	fp.Compose(
		Root.AsLabelled,
		as.HList8Labelled[NameIsA[int], NameIsB[string], NameIsC[float64], NameIsD[bool], NameIsE[*int], NameIsF[[]int], NameIsG[map[string]int], NameIsH[Child]],
	),
)

var DecoderRoot = js.DecoderMap(
	js.DecoderHConsLabelled(
		js.DecoderNamed[NameIsA[int]](js.DecoderNumber[int]()),
		js.DecoderHConsLabelled(
			js.DecoderNamed[NameIsB[string]](js.DecoderString),
			js.DecoderHConsLabelled(
				js.DecoderNamed[NameIsC[float64]](js.DecoderNumber[float64]()),
				js.DecoderHConsLabelled(
					js.DecoderNamed[NameIsD[bool]](js.DecoderBool),
					js.DecoderHConsLabelled(
						js.DecoderNamed[NameIsE[*int]](js.DecoderPtr(js.DecoderNumber[int]())),
						js.DecoderHConsLabelled(
							js.DecoderNamed[NameIsF[[]int]](js.DecoderSlice(js.DecoderNumber[int]())),
							js.DecoderHConsLabelled(
								js.DecoderNamed[NameIsG[map[string]int]](js.DecoderGoMap(js.DecoderNumber[int]())),
								js.DecoderHConsLabelled(
									js.DecoderNamed[NameIsH[Child]](DecoderChild),
									js.DecoderHNil,
								),
							),
						),
					),
				),
			),
		),
	),

	fp.Compose(
		product.LabelledFromHList8[NameIsA[int], NameIsB[string], NameIsC[float64], NameIsD[bool], NameIsE[*int], NameIsF[[]int], NameIsG[map[string]int], NameIsH[Child]],
		fp.Compose(
			as.Curried2(RootBuilder.FromLabelled)(RootBuilder{}),
			RootBuilder.Build,
		),
	),
)

var EncoderChild = js.EncoderContraMap(
	js.EncoderLabelled2(js.EncoderNamed[NameIsA[map[string]any]](js.EncoderGoMapAny), js.EncoderNamed[NameIsB[any]](js.EncoderGiven[any]())),
	Child.AsLabelled,
)

var DecoderChild = js.DecoderMap(
	js.DecoderLabelled2(js.DecoderNamed[NameIsA[map[string]any]](js.DecoderGoMapAny), js.DecoderNamed[NameIsB[any]](js.DecoderGiven[any]())),
	fp.Compose(
		as.Curried2(ChildBuilder.FromLabelled)(ChildBuilder{}),
		ChildBuilder.Build,
	),
)

func EncoderNode() js.Encoder[Node] {
	return js.EncoderContraMap(
		js.EncoderHConsLabelled(
			js.EncoderNamed[NameIsName[string]](js.EncoderString),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NameIsLeft[*Node]](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
					return EncoderNode()
				}))),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NameIsRight[*Node]](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
						return EncoderNode()
					}))),
					js.EncoderHNil,
				),
			),
		),
		fp.Compose(
			Node.AsLabelled,
			as.HList3Labelled[NameIsName[string], NameIsLeft[*Node], NameIsRight[*Node]],
		),
	)
}

var EncoderTree = js.EncoderContraMap(
	js.EncoderLabelled1(js.EncoderNamed[NameIsRoot[*Node]](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
		return EncoderNode()
	})))),
	Tree.AsLabelled,
)

func EncoderEntry[V any](encoderV js.Encoder[V]) js.Encoder[Entry[V]] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NameIsName[string]](js.EncoderString), js.EncoderNamed[NameIsValue[V]](encoderV)),
		Entry[V].AsLabelled,
	)
}

func EncoderNotUsedParam[K any, V any](encoderV js.Encoder[V]) js.Encoder[NotUsedParam[K, V]] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NameIsParam[string]](js.EncoderString), js.EncoderNamed[NameIsValue[V]](encoderV)),
		NotUsedParam[K, V].AsLabelled,
	)
}

var EncoderMovie = js.EncoderContraMap(
	js.EncoderLabelled2(js.EncoderNamed[NameIsName[string]](js.EncoderString), js.EncoderNamed[NameIsCasting[Entry[string]]](EncoderEntry(js.EncoderString))),
	Movie.AsLabelled,
)
