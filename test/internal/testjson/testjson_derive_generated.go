// Code generated by gombok, DO NOT EDIT.
package testjson

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
	"github.com/csgura/fp/hlist"
	"github.com/csgura/fp/lazy"
	"github.com/csgura/fp/test/internal/js"
)

func EncoderRoot() js.Encoder[Root] {
	return js.EncoderContraMap(
		js.EncoderHConsLabelled(
			js.EncoderNamed[NamedAOfRoot](js.EncoderNumber[int]()),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NamedBOfRoot](js.EncoderString),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NamedCOfRoot](js.EncoderNumber[float64]()),
					js.EncoderHConsLabelled(
						js.EncoderNamed[NamedDOfRoot](js.EncoderBool),
						js.EncoderHConsLabelled(
							js.EncoderNamed[NamedEOfRoot](js.EncoderPtr(lazy.Call(func() js.Encoder[int] {
								return js.EncoderNumber[int]()
							}))),
							js.EncoderHConsLabelled(
								js.EncoderNamed[NamedFOfRoot](js.EncoderSlice(js.EncoderNumber[int]())),
								js.EncoderHConsLabelled(
									js.EncoderNamed[NamedGOfRoot](js.EncoderGoMap(js.EncoderNumber[int]())),
									js.EncoderHConsLabelled(
										js.EncoderNamed[NamedHOfRoot](EncoderChild()),
										js.EncoderHNil,
									),
								),
							),
						),
					),
				),
			),
		),
		func(v Root) hlist.Cons[NamedAOfRoot, hlist.Cons[NamedBOfRoot, hlist.Cons[NamedCOfRoot, hlist.Cons[NamedDOfRoot, hlist.Cons[NamedEOfRoot, hlist.Cons[NamedFOfRoot, hlist.Cons[NamedGOfRoot, hlist.Cons[NamedHOfRoot, hlist.Nil]]]]]]]] {
			i0, i1, i2, i3, i4, i5, i6, i7 := v.Unapply()
			return hlist.Concat(NamedAOfRoot{i0},
				hlist.Concat(NamedBOfRoot{i1},
					hlist.Concat(NamedCOfRoot{i2},
						hlist.Concat(NamedDOfRoot{i3},
							hlist.Concat(NamedEOfRoot{i4},
								hlist.Concat(NamedFOfRoot{i5},
									hlist.Concat(NamedGOfRoot{i6},
										hlist.Concat(NamedHOfRoot{i7},
											hlist.Empty(),
										),
									),
								),
							),
						),
					),
				),
			)
		},
	)
}

func DecoderRoot() js.Decoder[Root] {
	return js.DecoderMap(
		js.DecoderHConsLabelled(
			js.DecoderNamed[NamedAOfRoot](js.DecoderNumber[int]()),
			js.DecoderHConsLabelled(
				js.DecoderNamed[NamedBOfRoot](js.DecoderString),
				js.DecoderHConsLabelled(
					js.DecoderNamed[NamedCOfRoot](js.DecoderNumber[float64]()),
					js.DecoderHConsLabelled(
						js.DecoderNamed[NamedDOfRoot](js.DecoderBool),
						js.DecoderHConsLabelled(
							js.DecoderNamed[NamedEOfRoot](js.DecoderPtr(lazy.Call(func() js.Decoder[int] {
								return js.DecoderNumber[int]()
							}))),
							js.DecoderHConsLabelled(
								js.DecoderNamed[NamedFOfRoot](js.DecoderSlice(js.DecoderNumber[int]())),
								js.DecoderHConsLabelled(
									js.DecoderNamed[NamedGOfRoot](js.DecoderGoMap(js.DecoderNumber[int]())),
									js.DecoderHConsLabelled(
										js.DecoderNamed[NamedHOfRoot](DecoderChild()),
										js.DecoderHNil,
									),
								),
							),
						),
					),
				),
			),
		),
		func(hl0 hlist.Cons[NamedAOfRoot, hlist.Cons[NamedBOfRoot, hlist.Cons[NamedCOfRoot, hlist.Cons[NamedDOfRoot, hlist.Cons[NamedEOfRoot, hlist.Cons[NamedFOfRoot, hlist.Cons[NamedGOfRoot, hlist.Cons[NamedHOfRoot, hlist.Nil]]]]]]]]) Root {
			i0, hl1 := hlist.Unapply(hl0)
			i1, hl2 := hlist.Unapply(hl1)
			i2, hl3 := hlist.Unapply(hl2)
			i3, hl4 := hlist.Unapply(hl3)
			i4, hl5 := hlist.Unapply(hl4)
			i5, hl6 := hlist.Unapply(hl5)
			i6, hl7 := hlist.Unapply(hl6)
			i7 := hlist.Head(hl7)
			return RootBuilder{}.Apply(i0.Value(), i1.Value(), i2.Value(), i3.Value(), i4.Value(), i5.Value(), i6.Value(), i7.Value()).Build()
		},
	)
}

func EncoderChild() js.Encoder[Child] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NamedAOfChild](js.EncoderGoMapAny), js.EncoderNamed[NamedBOfChild](js.EncoderGiven[any]())),
		Child.AsLabelled,
	)
}

func DecoderChild() js.Decoder[Child] {
	return js.DecoderMap(
		js.DecoderLabelled2(js.DecoderNamed[NamedAOfChild](js.DecoderGoMapAny), js.DecoderNamed[NamedBOfChild](js.DecoderGiven[any]())),
		fp.Compose(
			as.Curried2(ChildBuilder.FromLabelled)(ChildBuilder{}),
			ChildBuilder.Build,
		),
	)
}

func EncoderNode() js.Encoder[Node] {
	return js.EncoderContraMap(
		js.EncoderHConsLabelled(
			js.EncoderNamed[NamedNameOfNode](js.EncoderString),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NamedLeftOfNode](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
					return EncoderNode()
				}))),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NamedRightOfNode](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
						return EncoderNode()
					}))),
					js.EncoderHNil,
				),
			),
		),
		func(v Node) hlist.Cons[NamedNameOfNode, hlist.Cons[NamedLeftOfNode, hlist.Cons[NamedRightOfNode, hlist.Nil]]] {
			i0, i1, i2 := v.Unapply()
			return hlist.Concat(NamedNameOfNode{i0},
				hlist.Concat(NamedLeftOfNode{i1},
					hlist.Concat(NamedRightOfNode{i2},
						hlist.Empty(),
					),
				),
			)
		},
	)
}

func EncoderTree() js.Encoder[Tree] {
	return js.EncoderContraMap(
		js.EncoderLabelled1(js.EncoderNamed[NamedRootOfTree](js.EncoderPtr(lazy.Call(func() js.Encoder[Node] {
			return EncoderNode()
		})))),
		Tree.AsLabelled,
	)
}

func EncoderEntry[V any](encoderV js.Encoder[V]) js.Encoder[Entry[V]] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NamedNameOfEntry](js.EncoderString), js.EncoderNamed[NamedValueOfEntry[V]](encoderV)),
		Entry[V].AsLabelled,
	)
}

func EncoderNotUsedParam[K any, V any](encoderV js.Encoder[V]) js.Encoder[NotUsedParam[K, V]] {
	return js.EncoderContraMap(
		js.EncoderLabelled2(js.EncoderNamed[NamedParamOfNotUsedParam](js.EncoderString), js.EncoderNamed[NamedValueOfNotUsedParam[V]](encoderV)),
		NotUsedParam[K, V].AsLabelled,
	)
}

func EncoderMovie() js.Encoder[Movie] {
	return js.EncoderContraMap(
		js.EncoderHConsLabelled(
			js.EncoderNamed[NamedNameOfMovie](js.EncoderString),
			js.EncoderHConsLabelled(
				js.EncoderNamed[NamedCastingOfMovie](EncoderEntry(js.EncoderString)),
				js.EncoderHConsLabelled(
					js.EncoderNamed[NamedNotUsedOfMovie](EncoderNotUsedParam[int](js.EncoderString)),
					js.EncoderHNil,
				),
			),
		),
		func(v Movie) hlist.Cons[NamedNameOfMovie, hlist.Cons[NamedCastingOfMovie, hlist.Cons[NamedNotUsedOfMovie, hlist.Nil]]] {
			i0, i1, i2 := v.Unapply()
			return hlist.Concat(NamedNameOfMovie{i0},
				hlist.Concat(NamedCastingOfMovie{i1},
					hlist.Concat(NamedNotUsedOfMovie{i2},
						hlist.Empty(),
					),
				),
			)
		},
	)
}

func EncoderNoPrivate() js.Encoder[NoPrivate] {
	return js.EncoderContraMap(
		js.EncoderLabelled1(js.EncoderNamed[PubNamedRootOfNoPrivate](js.EncoderString)),
		NoPrivate.AsLabelled,
	)
}

func DecoderNoPrivate() js.Decoder[NoPrivate] {
	return js.DecoderMap(
		js.DecoderHConsLabelled(
			js.DecoderNamed[PubNamedRootOfNoPrivate](js.DecoderString),
			js.DecoderHNil,
		),
		func(hl0 hlist.Cons[PubNamedRootOfNoPrivate, hlist.Nil]) NoPrivate {
			i0 := hlist.Head(hl0)
			return NoPrivateBuilder{}.Apply(i0.Value()).Build()
		},
	)
}
