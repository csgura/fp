// Code generated by gombok, DO NOT EDIT.
package testjson

import (
	"fmt"
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
)

func (r Root) A() int {
	return r.a
}

func (r Root) B() string {
	return r.b
}

func (r Root) C() float64 {
	return r.c
}

func (r Root) D() bool {
	return r.d
}

func (r Root) E() *int {
	return r.e
}

func (r Root) F() []int {
	return r.f
}

func (r Root) G() map[string]int {
	return r.g
}

func (r Root) H() Child {
	return r.h
}

func (r Root) WithA(v int) Root {
	r.a = v
	return r
}

func (r Root) WithB(v string) Root {
	r.b = v
	return r
}

func (r Root) WithC(v float64) Root {
	r.c = v
	return r
}

func (r Root) WithD(v bool) Root {
	r.d = v
	return r
}

func (r Root) WithE(v *int) Root {
	r.e = v
	return r
}

func (r Root) WithF(v []int) Root {
	r.f = v
	return r
}

func (r Root) WithG(v map[string]int) Root {
	r.g = v
	return r
}

func (r Root) WithH(v Child) Root {
	r.h = v
	return r
}

func (r Root) String() string {
	return fmt.Sprintf("testjson.Root{a:%v, b:%v, c:%v, d:%v, e:%v, f:%v, g:%v, h:%v}", r.a, r.b, r.c, r.d, r.e, r.f, r.g, r.h)
}

func (r Root) AsTuple() fp.Tuple8[int, string, float64, bool, *int, []int, map[string]int, Child] {
	return as.Tuple8(r.a, r.b, r.c, r.d, r.e, r.f, r.g, r.h)
}

func (r Root) Unapply() (int, string, float64, bool, *int, []int, map[string]int, Child) {
	return r.a, r.b, r.c, r.d, r.e, r.f, r.g, r.h
}

func (r Root) AsMap() map[string]any {
	m := map[string]any{}
	m["a"] = r.a
	m["b"] = r.b
	m["c"] = r.c
	m["d"] = r.d
	m["e"] = r.e
	m["f"] = r.f
	m["g"] = r.g
	m["h"] = r.h
	return m
}

type NamedAOfRoot fp.Tuple1[int]

func (r NamedAOfRoot) Name() string {
	return "a"
}
func (r NamedAOfRoot) Value() int {
	return r.I1
}
func (r NamedAOfRoot) Tag() string {
	return ``
}
func (r NamedAOfRoot) Static() bool {
	return true
}
func (r NamedAOfRoot) WithValue(v int) NamedAOfRoot {
	r.I1 = v
	return r
}

type NamedBOfRoot fp.Tuple1[string]

func (r NamedBOfRoot) Name() string {
	return "b"
}
func (r NamedBOfRoot) Value() string {
	return r.I1
}
func (r NamedBOfRoot) Tag() string {
	return ``
}
func (r NamedBOfRoot) Static() bool {
	return true
}
func (r NamedBOfRoot) WithValue(v string) NamedBOfRoot {
	r.I1 = v
	return r
}

type NamedCOfRoot fp.Tuple1[float64]

func (r NamedCOfRoot) Name() string {
	return "c"
}
func (r NamedCOfRoot) Value() float64 {
	return r.I1
}
func (r NamedCOfRoot) Tag() string {
	return ``
}
func (r NamedCOfRoot) Static() bool {
	return true
}
func (r NamedCOfRoot) WithValue(v float64) NamedCOfRoot {
	r.I1 = v
	return r
}

type NamedDOfRoot fp.Tuple1[bool]

func (r NamedDOfRoot) Name() string {
	return "d"
}
func (r NamedDOfRoot) Value() bool {
	return r.I1
}
func (r NamedDOfRoot) Tag() string {
	return ``
}
func (r NamedDOfRoot) Static() bool {
	return true
}
func (r NamedDOfRoot) WithValue(v bool) NamedDOfRoot {
	r.I1 = v
	return r
}

type NamedEOfRoot fp.Tuple1[*int]

func (r NamedEOfRoot) Name() string {
	return "e"
}
func (r NamedEOfRoot) Value() *int {
	return r.I1
}
func (r NamedEOfRoot) Tag() string {
	return ``
}
func (r NamedEOfRoot) Static() bool {
	return true
}
func (r NamedEOfRoot) WithValue(v *int) NamedEOfRoot {
	r.I1 = v
	return r
}

type NamedFOfRoot fp.Tuple1[[]int]

func (r NamedFOfRoot) Name() string {
	return "f"
}
func (r NamedFOfRoot) Value() []int {
	return r.I1
}
func (r NamedFOfRoot) Tag() string {
	return ``
}
func (r NamedFOfRoot) Static() bool {
	return true
}
func (r NamedFOfRoot) WithValue(v []int) NamedFOfRoot {
	r.I1 = v
	return r
}

type NamedGOfRoot fp.Tuple1[map[string]int]

func (r NamedGOfRoot) Name() string {
	return "g"
}
func (r NamedGOfRoot) Value() map[string]int {
	return r.I1
}
func (r NamedGOfRoot) Tag() string {
	return ``
}
func (r NamedGOfRoot) Static() bool {
	return true
}
func (r NamedGOfRoot) WithValue(v map[string]int) NamedGOfRoot {
	r.I1 = v
	return r
}

type NamedHOfRoot fp.Tuple1[Child]

func (r NamedHOfRoot) Name() string {
	return "h"
}
func (r NamedHOfRoot) Value() Child {
	return r.I1
}
func (r NamedHOfRoot) Tag() string {
	return ``
}
func (r NamedHOfRoot) Static() bool {
	return true
}
func (r NamedHOfRoot) WithValue(v Child) NamedHOfRoot {
	r.I1 = v
	return r
}

func (r Root) AsLabelled() fp.Labelled8[NamedAOfRoot, NamedBOfRoot, NamedCOfRoot, NamedDOfRoot, NamedEOfRoot, NamedFOfRoot, NamedGOfRoot, NamedHOfRoot] {
	return as.Labelled8(NamedAOfRoot{r.a}, NamedBOfRoot{r.b}, NamedCOfRoot{r.c}, NamedDOfRoot{r.d}, NamedEOfRoot{r.e}, NamedFOfRoot{r.f}, NamedGOfRoot{r.g}, NamedHOfRoot{r.h})
}

type RootBuilder Root

func (r RootBuilder) Build() Root {
	return Root(r)
}

func (r Root) Builder() RootBuilder {
	return RootBuilder(r)
}

func (r RootBuilder) A(v int) RootBuilder {
	r.a = v
	return r
}

func (r RootBuilder) B(v string) RootBuilder {
	r.b = v
	return r
}

func (r RootBuilder) C(v float64) RootBuilder {
	r.c = v
	return r
}

func (r RootBuilder) D(v bool) RootBuilder {
	r.d = v
	return r
}

func (r RootBuilder) E(v *int) RootBuilder {
	r.e = v
	return r
}

func (r RootBuilder) F(v []int) RootBuilder {
	r.f = v
	return r
}

func (r RootBuilder) G(v map[string]int) RootBuilder {
	r.g = v
	return r
}

func (r RootBuilder) H(v Child) RootBuilder {
	r.h = v
	return r
}

func (r RootBuilder) FromTuple(t fp.Tuple8[int, string, float64, bool, *int, []int, map[string]int, Child]) RootBuilder {
	r.a = t.I1
	r.b = t.I2
	r.c = t.I3
	r.d = t.I4
	r.e = t.I5
	r.f = t.I6
	r.g = t.I7
	r.h = t.I8
	return r
}

func (r RootBuilder) Apply(a int, b string, c float64, d bool, e *int, f []int, g map[string]int, h Child) RootBuilder {
	r.a = a
	r.b = b
	r.c = c
	r.d = d
	r.e = e
	r.f = f
	r.g = g
	r.h = h
	return r
}

func (r RootBuilder) FromMap(m map[string]any) RootBuilder {

	if v, ok := m["a"].(int); ok {
		r.a = v
	}

	if v, ok := m["b"].(string); ok {
		r.b = v
	}

	if v, ok := m["c"].(float64); ok {
		r.c = v
	}

	if v, ok := m["d"].(bool); ok {
		r.d = v
	}

	if v, ok := m["e"].(*int); ok {
		r.e = v
	}

	if v, ok := m["f"].([]int); ok {
		r.f = v
	}

	if v, ok := m["g"].(map[string]int); ok {
		r.g = v
	}

	if v, ok := m["h"].(Child); ok {
		r.h = v
	}

	return r
}

func (r RootBuilder) FromLabelled(t fp.Labelled8[NamedAOfRoot, NamedBOfRoot, NamedCOfRoot, NamedDOfRoot, NamedEOfRoot, NamedFOfRoot, NamedGOfRoot, NamedHOfRoot]) RootBuilder {
	r.a = t.I1.Value()
	r.b = t.I2.Value()
	r.c = t.I3.Value()
	r.d = t.I4.Value()
	r.e = t.I5.Value()
	r.f = t.I6.Value()
	r.g = t.I7.Value()
	r.h = t.I8.Value()
	return r
}

type RootMutable struct {
	A int
	B string
	C float64
	D bool
	E *int
	F []int
	G map[string]int
	H Child
}

func (r Root) AsMutable() RootMutable {
	return RootMutable{
		A: r.a,
		B: r.b,
		C: r.c,
		D: r.d,
		E: r.e,
		F: r.f,
		G: r.g,
		H: r.h,
	}
}

func (r RootMutable) AsImmutable() Root {
	return Root{
		a: r.A,
		b: r.B,
		c: r.C,
		d: r.D,
		e: r.E,
		f: r.F,
		g: r.G,
		h: r.H,
	}
}

func (r Child) A() map[string]any {
	return r.a
}

func (r Child) B() any {
	return r.b
}

func (r Child) WithA(v map[string]any) Child {
	r.a = v
	return r
}

func (r Child) WithB(v any) Child {
	r.b = v
	return r
}

func (r Child) String() string {
	return fmt.Sprintf("testjson.Child{a:%v, b:%v}", r.a, r.b)
}

func (r Child) AsTuple() fp.Tuple2[map[string]any, any] {
	return as.Tuple2(r.a, r.b)
}

func (r Child) Unapply() (map[string]any, any) {
	return r.a, r.b
}

func (r Child) AsMap() map[string]any {
	m := map[string]any{}
	m["a"] = r.a
	m["b"] = r.b
	return m
}

type NamedAOfChild fp.Tuple1[map[string]any]

func (r NamedAOfChild) Name() string {
	return "a"
}
func (r NamedAOfChild) Value() map[string]any {
	return r.I1
}
func (r NamedAOfChild) Tag() string {
	return ``
}
func (r NamedAOfChild) Static() bool {
	return true
}
func (r NamedAOfChild) WithValue(v map[string]any) NamedAOfChild {
	r.I1 = v
	return r
}

type NamedBOfChild fp.Tuple1[any]

func (r NamedBOfChild) Name() string {
	return "b"
}
func (r NamedBOfChild) Value() any {
	return r.I1
}
func (r NamedBOfChild) Tag() string {
	return ``
}
func (r NamedBOfChild) Static() bool {
	return true
}
func (r NamedBOfChild) WithValue(v any) NamedBOfChild {
	r.I1 = v
	return r
}

func (r Child) AsLabelled() fp.Labelled2[NamedAOfChild, NamedBOfChild] {
	return as.Labelled2(NamedAOfChild{r.a}, NamedBOfChild{r.b})
}

type ChildBuilder Child

func (r ChildBuilder) Build() Child {
	return Child(r)
}

func (r Child) Builder() ChildBuilder {
	return ChildBuilder(r)
}

func (r ChildBuilder) A(v map[string]any) ChildBuilder {
	r.a = v
	return r
}

func (r ChildBuilder) B(v any) ChildBuilder {
	r.b = v
	return r
}

func (r ChildBuilder) FromTuple(t fp.Tuple2[map[string]any, any]) ChildBuilder {
	r.a = t.I1
	r.b = t.I2
	return r
}

func (r ChildBuilder) Apply(a map[string]any, b any) ChildBuilder {
	r.a = a
	r.b = b
	return r
}

func (r ChildBuilder) FromMap(m map[string]any) ChildBuilder {

	if v, ok := m["a"].(map[string]any); ok {
		r.a = v
	}

	if v, ok := m["b"].(any); ok {
		r.b = v
	}

	return r
}

func (r ChildBuilder) FromLabelled(t fp.Labelled2[NamedAOfChild, NamedBOfChild]) ChildBuilder {
	r.a = t.I1.Value()
	r.b = t.I2.Value()
	return r
}

type ChildMutable struct {
	A map[string]any
	B any
}

func (r Child) AsMutable() ChildMutable {
	return ChildMutable{
		A: r.a,
		B: r.b,
	}
}

func (r ChildMutable) AsImmutable() Child {
	return Child{
		a: r.A,
		b: r.B,
	}
}

func (r Node) Name() string {
	return r.name
}

func (r Node) Left() *Node {
	return r.left
}

func (r Node) Right() *Node {
	return r.right
}

func (r Node) WithName(v string) Node {
	r.name = v
	return r
}

func (r Node) WithLeft(v *Node) Node {
	r.left = v
	return r
}

func (r Node) WithRight(v *Node) Node {
	r.right = v
	return r
}

func (r Node) String() string {
	return fmt.Sprintf("testjson.Node{name:%v, left:%v, right:%v}", r.name, r.left, r.right)
}

func (r Node) AsTuple() fp.Tuple3[string, *Node, *Node] {
	return as.Tuple3(r.name, r.left, r.right)
}

func (r Node) Unapply() (string, *Node, *Node) {
	return r.name, r.left, r.right
}

func (r Node) AsMap() map[string]any {
	m := map[string]any{}
	m["name"] = r.name
	m["left"] = r.left
	m["right"] = r.right
	return m
}

type NamedNameOfNode fp.Tuple1[string]

func (r NamedNameOfNode) Name() string {
	return "name"
}
func (r NamedNameOfNode) Value() string {
	return r.I1
}
func (r NamedNameOfNode) Tag() string {
	return ``
}
func (r NamedNameOfNode) Static() bool {
	return true
}
func (r NamedNameOfNode) WithValue(v string) NamedNameOfNode {
	r.I1 = v
	return r
}

type NamedLeftOfNode fp.Tuple1[*Node]

func (r NamedLeftOfNode) Name() string {
	return "left"
}
func (r NamedLeftOfNode) Value() *Node {
	return r.I1
}
func (r NamedLeftOfNode) Tag() string {
	return ``
}
func (r NamedLeftOfNode) Static() bool {
	return true
}
func (r NamedLeftOfNode) WithValue(v *Node) NamedLeftOfNode {
	r.I1 = v
	return r
}

type NamedRightOfNode fp.Tuple1[*Node]

func (r NamedRightOfNode) Name() string {
	return "right"
}
func (r NamedRightOfNode) Value() *Node {
	return r.I1
}
func (r NamedRightOfNode) Tag() string {
	return ``
}
func (r NamedRightOfNode) Static() bool {
	return true
}
func (r NamedRightOfNode) WithValue(v *Node) NamedRightOfNode {
	r.I1 = v
	return r
}

func (r Node) AsLabelled() fp.Labelled3[NamedNameOfNode, NamedLeftOfNode, NamedRightOfNode] {
	return as.Labelled3(NamedNameOfNode{r.name}, NamedLeftOfNode{r.left}, NamedRightOfNode{r.right})
}

type NodeBuilder Node

func (r NodeBuilder) Build() Node {
	return Node(r)
}

func (r Node) Builder() NodeBuilder {
	return NodeBuilder(r)
}

func (r NodeBuilder) Name(v string) NodeBuilder {
	r.name = v
	return r
}

func (r NodeBuilder) Left(v *Node) NodeBuilder {
	r.left = v
	return r
}

func (r NodeBuilder) Right(v *Node) NodeBuilder {
	r.right = v
	return r
}

func (r NodeBuilder) FromTuple(t fp.Tuple3[string, *Node, *Node]) NodeBuilder {
	r.name = t.I1
	r.left = t.I2
	r.right = t.I3
	return r
}

func (r NodeBuilder) Apply(name string, left *Node, right *Node) NodeBuilder {
	r.name = name
	r.left = left
	r.right = right
	return r
}

func (r NodeBuilder) FromMap(m map[string]any) NodeBuilder {

	if v, ok := m["name"].(string); ok {
		r.name = v
	}

	if v, ok := m["left"].(*Node); ok {
		r.left = v
	}

	if v, ok := m["right"].(*Node); ok {
		r.right = v
	}

	return r
}

func (r NodeBuilder) FromLabelled(t fp.Labelled3[NamedNameOfNode, NamedLeftOfNode, NamedRightOfNode]) NodeBuilder {
	r.name = t.I1.Value()
	r.left = t.I2.Value()
	r.right = t.I3.Value()
	return r
}

type NodeMutable struct {
	Name  string
	Left  *Node
	Right *Node
}

func (r Node) AsMutable() NodeMutable {
	return NodeMutable{
		Name:  r.name,
		Left:  r.left,
		Right: r.right,
	}
}

func (r NodeMutable) AsImmutable() Node {
	return Node{
		name:  r.Name,
		left:  r.Left,
		right: r.Right,
	}
}

func (r Tree) Root() *Node {
	return r.root
}

func (r Tree) WithRoot(v *Node) Tree {
	r.root = v
	return r
}

func (r Tree) String() string {
	return fmt.Sprintf("testjson.Tree{root:%v}", r.root)
}

func (r Tree) AsTuple() fp.Tuple1[*Node] {
	return as.Tuple1(r.root)
}

func (r Tree) Unapply() *Node {
	return r.root
}

func (r Tree) AsMap() map[string]any {
	m := map[string]any{}
	m["root"] = r.root
	return m
}

type NamedRootOfTree fp.Tuple1[*Node]

func (r NamedRootOfTree) Name() string {
	return "root"
}
func (r NamedRootOfTree) Value() *Node {
	return r.I1
}
func (r NamedRootOfTree) Tag() string {
	return ``
}
func (r NamedRootOfTree) Static() bool {
	return true
}
func (r NamedRootOfTree) WithValue(v *Node) NamedRootOfTree {
	r.I1 = v
	return r
}

func (r Tree) AsLabelled() fp.Labelled1[NamedRootOfTree] {
	return as.Labelled1(NamedRootOfTree{r.root})
}

type TreeBuilder Tree

func (r TreeBuilder) Build() Tree {
	return Tree(r)
}

func (r Tree) Builder() TreeBuilder {
	return TreeBuilder(r)
}

func (r TreeBuilder) Root(v *Node) TreeBuilder {
	r.root = v
	return r
}

func (r TreeBuilder) FromTuple(t fp.Tuple1[*Node]) TreeBuilder {
	r.root = t.I1
	return r
}

func (r TreeBuilder) Apply(root *Node) TreeBuilder {
	r.root = root
	return r
}

func (r TreeBuilder) FromMap(m map[string]any) TreeBuilder {

	if v, ok := m["root"].(*Node); ok {
		r.root = v
	}

	return r
}

func (r TreeBuilder) FromLabelled(t fp.Labelled1[NamedRootOfTree]) TreeBuilder {
	r.root = t.I1.Value()
	return r
}

type TreeMutable struct {
	Root *Node
}

func (r Tree) AsMutable() TreeMutable {
	return TreeMutable{
		Root: r.root,
	}
}

func (r TreeMutable) AsImmutable() Tree {
	return Tree{
		root: r.Root,
	}
}

func (r Entry[V]) Name() string {
	return r.name
}

func (r Entry[V]) Value() V {
	return r.value
}

func (r Entry[V]) WithName(v string) Entry[V] {
	r.name = v
	return r
}

func (r Entry[V]) WithValue(v V) Entry[V] {
	r.value = v
	return r
}

func (r Entry[V]) String() string {
	return fmt.Sprintf("testjson.Entry{name:%v, value:%v}", r.name, r.value)
}

func (r Entry[V]) AsTuple() fp.Tuple2[string, V] {
	return as.Tuple2(r.name, r.value)
}

func (r Entry[V]) Unapply() (string, V) {
	return r.name, r.value
}

func (r Entry[V]) AsMap() map[string]any {
	m := map[string]any{}
	m["name"] = r.name
	m["value"] = r.value
	return m
}

type NamedNameOfEntry fp.Tuple1[string]

func (r NamedNameOfEntry) Name() string {
	return "name"
}
func (r NamedNameOfEntry) Value() string {
	return r.I1
}
func (r NamedNameOfEntry) Tag() string {
	return ``
}
func (r NamedNameOfEntry) Static() bool {
	return true
}
func (r NamedNameOfEntry) WithValue(v string) NamedNameOfEntry {
	r.I1 = v
	return r
}

type NamedValueOfEntry[V any] fp.Tuple1[V]

func (r NamedValueOfEntry[V]) Name() string {
	return "value"
}
func (r NamedValueOfEntry[V]) Value() V {
	return r.I1
}
func (r NamedValueOfEntry[V]) Tag() string {
	return ``
}
func (r NamedValueOfEntry[V]) Static() bool {
	return true
}
func (r NamedValueOfEntry[V]) WithValue(v V) NamedValueOfEntry[V] {
	r.I1 = v
	return r
}

func (r Entry[V]) AsLabelled() fp.Labelled2[NamedNameOfEntry, NamedValueOfEntry[V]] {
	return as.Labelled2(NamedNameOfEntry{r.name}, NamedValueOfEntry[V]{r.value})
}

type EntryBuilder[V any] Entry[V]

func (r EntryBuilder[V]) Build() Entry[V] {
	return Entry[V](r)
}

func (r Entry[V]) Builder() EntryBuilder[V] {
	return EntryBuilder[V](r)
}

func (r EntryBuilder[V]) Name(v string) EntryBuilder[V] {
	r.name = v
	return r
}

func (r EntryBuilder[V]) Value(v V) EntryBuilder[V] {
	r.value = v
	return r
}

func (r EntryBuilder[V]) FromTuple(t fp.Tuple2[string, V]) EntryBuilder[V] {
	r.name = t.I1
	r.value = t.I2
	return r
}

func (r EntryBuilder[V]) Apply(name string, value V) EntryBuilder[V] {
	r.name = name
	r.value = value
	return r
}

func (r EntryBuilder[V]) FromMap(m map[string]any) EntryBuilder[V] {

	if v, ok := m["name"].(string); ok {
		r.name = v
	}

	if v, ok := m["value"].(V); ok {
		r.value = v
	}

	return r
}

func (r EntryBuilder[V]) FromLabelled(t fp.Labelled2[NamedNameOfEntry, NamedValueOfEntry[V]]) EntryBuilder[V] {
	r.name = t.I1.Value()
	r.value = t.I2.Value()
	return r
}

type EntryMutable[V any] struct {
	Name  string
	Value V
}

func (r Entry[V]) AsMutable() EntryMutable[V] {
	return EntryMutable[V]{
		Name:  r.name,
		Value: r.value,
	}
}

func (r EntryMutable[V]) AsImmutable() Entry[V] {
	return Entry[V]{
		name:  r.Name,
		value: r.Value,
	}
}

func (r NotUsedParam[K, V]) Param() string {
	return r.param
}

func (r NotUsedParam[K, V]) Value() V {
	return r.value
}

func (r NotUsedParam[K, V]) WithParam(v string) NotUsedParam[K, V] {
	r.param = v
	return r
}

func (r NotUsedParam[K, V]) WithValue(v V) NotUsedParam[K, V] {
	r.value = v
	return r
}

func (r NotUsedParam[K, V]) String() string {
	return fmt.Sprintf("testjson.NotUsedParam{param:%v, value:%v}", r.param, r.value)
}

func (r NotUsedParam[K, V]) AsTuple() fp.Tuple2[string, V] {
	return as.Tuple2(r.param, r.value)
}

func (r NotUsedParam[K, V]) Unapply() (string, V) {
	return r.param, r.value
}

func (r NotUsedParam[K, V]) AsMap() map[string]any {
	m := map[string]any{}
	m["param"] = r.param
	m["value"] = r.value
	return m
}

type NamedParamOfNotUsedParam fp.Tuple1[string]

func (r NamedParamOfNotUsedParam) Name() string {
	return "param"
}
func (r NamedParamOfNotUsedParam) Value() string {
	return r.I1
}
func (r NamedParamOfNotUsedParam) Tag() string {
	return ``
}
func (r NamedParamOfNotUsedParam) Static() bool {
	return true
}
func (r NamedParamOfNotUsedParam) WithValue(v string) NamedParamOfNotUsedParam {
	r.I1 = v
	return r
}

type NamedValueOfNotUsedParam[V any] fp.Tuple1[V]

func (r NamedValueOfNotUsedParam[V]) Name() string {
	return "value"
}
func (r NamedValueOfNotUsedParam[V]) Value() V {
	return r.I1
}
func (r NamedValueOfNotUsedParam[V]) Tag() string {
	return ``
}
func (r NamedValueOfNotUsedParam[V]) Static() bool {
	return true
}
func (r NamedValueOfNotUsedParam[V]) WithValue(v V) NamedValueOfNotUsedParam[V] {
	r.I1 = v
	return r
}

func (r NotUsedParam[K, V]) AsLabelled() fp.Labelled2[NamedParamOfNotUsedParam, NamedValueOfNotUsedParam[V]] {
	return as.Labelled2(NamedParamOfNotUsedParam{r.param}, NamedValueOfNotUsedParam[V]{r.value})
}

type NotUsedParamBuilder[K any, V any] NotUsedParam[K, V]

func (r NotUsedParamBuilder[K, V]) Build() NotUsedParam[K, V] {
	return NotUsedParam[K, V](r)
}

func (r NotUsedParam[K, V]) Builder() NotUsedParamBuilder[K, V] {
	return NotUsedParamBuilder[K, V](r)
}

func (r NotUsedParamBuilder[K, V]) Param(v string) NotUsedParamBuilder[K, V] {
	r.param = v
	return r
}

func (r NotUsedParamBuilder[K, V]) Value(v V) NotUsedParamBuilder[K, V] {
	r.value = v
	return r
}

func (r NotUsedParamBuilder[K, V]) FromTuple(t fp.Tuple2[string, V]) NotUsedParamBuilder[K, V] {
	r.param = t.I1
	r.value = t.I2
	return r
}

func (r NotUsedParamBuilder[K, V]) Apply(param string, value V) NotUsedParamBuilder[K, V] {
	r.param = param
	r.value = value
	return r
}

func (r NotUsedParamBuilder[K, V]) FromMap(m map[string]any) NotUsedParamBuilder[K, V] {

	if v, ok := m["param"].(string); ok {
		r.param = v
	}

	if v, ok := m["value"].(V); ok {
		r.value = v
	}

	return r
}

func (r NotUsedParamBuilder[K, V]) FromLabelled(t fp.Labelled2[NamedParamOfNotUsedParam, NamedValueOfNotUsedParam[V]]) NotUsedParamBuilder[K, V] {
	r.param = t.I1.Value()
	r.value = t.I2.Value()
	return r
}

type NotUsedParamMutable[K any, V any] struct {
	Param string
	Value V
}

func (r NotUsedParam[K, V]) AsMutable() NotUsedParamMutable[K, V] {
	return NotUsedParamMutable[K, V]{
		Param: r.param,
		Value: r.value,
	}
}

func (r NotUsedParamMutable[K, V]) AsImmutable() NotUsedParam[K, V] {
	return NotUsedParam[K, V]{
		param: r.Param,
		value: r.Value,
	}
}

func (r Movie) Name() string {
	return r.name
}

func (r Movie) Casting() Entry[string] {
	return r.casting
}

func (r Movie) NotUsed() NotUsedParam[int, string] {
	return r.notUsed
}

func (r Movie) WithName(v string) Movie {
	r.name = v
	return r
}

func (r Movie) WithCasting(v Entry[string]) Movie {
	r.casting = v
	return r
}

func (r Movie) WithNotUsed(v NotUsedParam[int, string]) Movie {
	r.notUsed = v
	return r
}

func (r Movie) String() string {
	return fmt.Sprintf("testjson.Movie{name:%v, casting:%v, notUsed:%v}", r.name, r.casting, r.notUsed)
}

func (r Movie) AsTuple() fp.Tuple3[string, Entry[string], NotUsedParam[int, string]] {
	return as.Tuple3(r.name, r.casting, r.notUsed)
}

func (r Movie) Unapply() (string, Entry[string], NotUsedParam[int, string]) {
	return r.name, r.casting, r.notUsed
}

func (r Movie) AsMap() map[string]any {
	m := map[string]any{}
	m["name"] = r.name
	m["casting"] = r.casting
	m["notUsed"] = r.notUsed
	return m
}

type NamedNameOfMovie fp.Tuple1[string]

func (r NamedNameOfMovie) Name() string {
	return "name"
}
func (r NamedNameOfMovie) Value() string {
	return r.I1
}
func (r NamedNameOfMovie) Tag() string {
	return ``
}
func (r NamedNameOfMovie) Static() bool {
	return true
}
func (r NamedNameOfMovie) WithValue(v string) NamedNameOfMovie {
	r.I1 = v
	return r
}

type NamedCastingOfMovie fp.Tuple1[Entry[string]]

func (r NamedCastingOfMovie) Name() string {
	return "casting"
}
func (r NamedCastingOfMovie) Value() Entry[string] {
	return r.I1
}
func (r NamedCastingOfMovie) Tag() string {
	return ``
}
func (r NamedCastingOfMovie) Static() bool {
	return true
}
func (r NamedCastingOfMovie) WithValue(v Entry[string]) NamedCastingOfMovie {
	r.I1 = v
	return r
}

type NamedNotUsedOfMovie fp.Tuple1[NotUsedParam[int, string]]

func (r NamedNotUsedOfMovie) Name() string {
	return "notUsed"
}
func (r NamedNotUsedOfMovie) Value() NotUsedParam[int, string] {
	return r.I1
}
func (r NamedNotUsedOfMovie) Tag() string {
	return ``
}
func (r NamedNotUsedOfMovie) Static() bool {
	return true
}
func (r NamedNotUsedOfMovie) WithValue(v NotUsedParam[int, string]) NamedNotUsedOfMovie {
	r.I1 = v
	return r
}

func (r Movie) AsLabelled() fp.Labelled3[NamedNameOfMovie, NamedCastingOfMovie, NamedNotUsedOfMovie] {
	return as.Labelled3(NamedNameOfMovie{r.name}, NamedCastingOfMovie{r.casting}, NamedNotUsedOfMovie{r.notUsed})
}

type MovieBuilder Movie

func (r MovieBuilder) Build() Movie {
	return Movie(r)
}

func (r Movie) Builder() MovieBuilder {
	return MovieBuilder(r)
}

func (r MovieBuilder) Name(v string) MovieBuilder {
	r.name = v
	return r
}

func (r MovieBuilder) Casting(v Entry[string]) MovieBuilder {
	r.casting = v
	return r
}

func (r MovieBuilder) NotUsed(v NotUsedParam[int, string]) MovieBuilder {
	r.notUsed = v
	return r
}

func (r MovieBuilder) FromTuple(t fp.Tuple3[string, Entry[string], NotUsedParam[int, string]]) MovieBuilder {
	r.name = t.I1
	r.casting = t.I2
	r.notUsed = t.I3
	return r
}

func (r MovieBuilder) Apply(name string, casting Entry[string], notUsed NotUsedParam[int, string]) MovieBuilder {
	r.name = name
	r.casting = casting
	r.notUsed = notUsed
	return r
}

func (r MovieBuilder) FromMap(m map[string]any) MovieBuilder {

	if v, ok := m["name"].(string); ok {
		r.name = v
	}

	if v, ok := m["casting"].(Entry[string]); ok {
		r.casting = v
	}

	if v, ok := m["notUsed"].(NotUsedParam[int, string]); ok {
		r.notUsed = v
	}

	return r
}

func (r MovieBuilder) FromLabelled(t fp.Labelled3[NamedNameOfMovie, NamedCastingOfMovie, NamedNotUsedOfMovie]) MovieBuilder {
	r.name = t.I1.Value()
	r.casting = t.I2.Value()
	r.notUsed = t.I3.Value()
	return r
}

type MovieMutable struct {
	Name    string
	Casting Entry[string]
	NotUsed NotUsedParam[int, string]
}

func (r Movie) AsMutable() MovieMutable {
	return MovieMutable{
		Name:    r.name,
		Casting: r.casting,
		NotUsed: r.notUsed,
	}
}

func (r MovieMutable) AsImmutable() Movie {
	return Movie{
		name:    r.Name,
		casting: r.Casting,
		notUsed: r.NotUsed,
	}
}

func (r NoPrivate) String() string {
	return fmt.Sprintf("testjson.NoPrivate{Root:%v}", r.Root)
}

func (r NoPrivate) AsTuple() fp.Tuple1[string] {
	return as.Tuple1(r.Root)
}

func (r NoPrivate) Unapply() string {
	return r.Root
}

func (r NoPrivate) AsMap() map[string]any {
	m := map[string]any{}
	m["Root"] = r.Root
	return m
}

type PubNamedRootOfNoPrivate fp.Tuple1[string]

func (r PubNamedRootOfNoPrivate) Name() string {
	return "Root"
}
func (r PubNamedRootOfNoPrivate) Value() string {
	return r.I1
}
func (r PubNamedRootOfNoPrivate) Tag() string {
	return ``
}
func (r PubNamedRootOfNoPrivate) Static() bool {
	return true
}
func (r PubNamedRootOfNoPrivate) WithValue(v string) PubNamedRootOfNoPrivate {
	r.I1 = v
	return r
}

func (r NoPrivate) AsLabelled() fp.Labelled1[PubNamedRootOfNoPrivate] {
	return as.Labelled1(PubNamedRootOfNoPrivate{r.Root})
}

type NoPrivateBuilder NoPrivate

func (r NoPrivateBuilder) Build() NoPrivate {
	return NoPrivate(r)
}

func (r NoPrivate) Builder() NoPrivateBuilder {
	return NoPrivateBuilder(r)
}

func (r NoPrivateBuilder) FromTuple(t fp.Tuple1[string]) NoPrivateBuilder {
	r.Root = t.I1
	return r
}

func (r NoPrivateBuilder) Apply(Root string) NoPrivateBuilder {
	r.Root = Root
	return r
}

func (r NoPrivateBuilder) FromMap(m map[string]any) NoPrivateBuilder {

	if v, ok := m["Root"].(string); ok {
		r.Root = v
	}

	return r
}

func (r NoPrivateBuilder) FromLabelled(t fp.Labelled1[PubNamedRootOfNoPrivate]) NoPrivateBuilder {
	r.Root = t.I1.Value()
	return r
}

type NoPrivateMutable struct {
	Root string
}

func (r NoPrivate) AsMutable() NoPrivateMutable {
	return NoPrivateMutable{
		Root: r.Root,
	}
}

func (r NoPrivateMutable) AsImmutable() NoPrivate {
	return NoPrivate{
		Root: r.Root,
	}
}
