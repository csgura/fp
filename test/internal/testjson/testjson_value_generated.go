// Code generated by gombok, DO NOT EDIT.
package testjson

import (
	"fmt"
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
)

func (r Root) A() int {
	return r.a
}

func (r Root) B() string {
	return r.b
}

func (r Root) C() float64 {
	return r.c
}

func (r Root) D() bool {
	return r.d
}

func (r Root) E() *int {
	return r.e
}

func (r Root) F() []int {
	return r.f
}

func (r Root) G() map[string]int {
	return r.g
}

func (r Root) H() Child {
	return r.h
}

func (r Root) WithA(v int) Root {
	r.a = v
	return r
}

func (r Root) WithB(v string) Root {
	r.b = v
	return r
}

func (r Root) WithC(v float64) Root {
	r.c = v
	return r
}

func (r Root) WithD(v bool) Root {
	r.d = v
	return r
}

func (r Root) WithE(v *int) Root {
	r.e = v
	return r
}

func (r Root) WithF(v []int) Root {
	r.f = v
	return r
}

func (r Root) WithG(v map[string]int) Root {
	r.g = v
	return r
}

func (r Root) WithH(v Child) Root {
	r.h = v
	return r
}

func (r Root) String() string {
	return fmt.Sprintf("testjson.Root{a:%v, b:%v, c:%v, d:%v, e:%v, f:%v, g:%v, h:%v}", r.a, r.b, r.c, r.d, r.e, r.f, r.g, r.h)
}

func (r Root) AsTuple() fp.Tuple8[int, string, float64, bool, *int, []int, map[string]int, Child] {
	return as.Tuple8(r.a, r.b, r.c, r.d, r.e, r.f, r.g, r.h)
}

func (r Root) Unapply() (int, string, float64, bool, *int, []int, map[string]int, Child) {
	return r.a, r.b, r.c, r.d, r.e, r.f, r.g, r.h
}

func (r Root) AsMap() map[string]any {
	m := map[string]any{}
	m["a"] = r.a
	m["b"] = r.b
	m["c"] = r.c
	m["d"] = r.d
	m["e"] = r.e
	m["f"] = r.f
	m["g"] = r.g
	m["h"] = r.h
	return m
}

type NamedAOfRoot[T any] fp.Tuple1[T]

func (r NamedAOfRoot[T]) Name() string {
	return "a"
}
func (r NamedAOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedAOfRoot[T]) Tag() string {
	return ``
}
func (r NamedAOfRoot[T]) WithValue(v T) NamedAOfRoot[T] {
	r.I1 = v
	return r
}

type NamedBOfRoot[T any] fp.Tuple1[T]

func (r NamedBOfRoot[T]) Name() string {
	return "b"
}
func (r NamedBOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedBOfRoot[T]) Tag() string {
	return ``
}
func (r NamedBOfRoot[T]) WithValue(v T) NamedBOfRoot[T] {
	r.I1 = v
	return r
}

type NamedCOfRoot[T any] fp.Tuple1[T]

func (r NamedCOfRoot[T]) Name() string {
	return "c"
}
func (r NamedCOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedCOfRoot[T]) Tag() string {
	return ``
}
func (r NamedCOfRoot[T]) WithValue(v T) NamedCOfRoot[T] {
	r.I1 = v
	return r
}

type NamedDOfRoot[T any] fp.Tuple1[T]

func (r NamedDOfRoot[T]) Name() string {
	return "d"
}
func (r NamedDOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedDOfRoot[T]) Tag() string {
	return ``
}
func (r NamedDOfRoot[T]) WithValue(v T) NamedDOfRoot[T] {
	r.I1 = v
	return r
}

type NamedEOfRoot[T any] fp.Tuple1[T]

func (r NamedEOfRoot[T]) Name() string {
	return "e"
}
func (r NamedEOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedEOfRoot[T]) Tag() string {
	return ``
}
func (r NamedEOfRoot[T]) WithValue(v T) NamedEOfRoot[T] {
	r.I1 = v
	return r
}

type NamedFOfRoot[T any] fp.Tuple1[T]

func (r NamedFOfRoot[T]) Name() string {
	return "f"
}
func (r NamedFOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedFOfRoot[T]) Tag() string {
	return ``
}
func (r NamedFOfRoot[T]) WithValue(v T) NamedFOfRoot[T] {
	r.I1 = v
	return r
}

type NamedGOfRoot[T any] fp.Tuple1[T]

func (r NamedGOfRoot[T]) Name() string {
	return "g"
}
func (r NamedGOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedGOfRoot[T]) Tag() string {
	return ``
}
func (r NamedGOfRoot[T]) WithValue(v T) NamedGOfRoot[T] {
	r.I1 = v
	return r
}

type NamedHOfRoot[T any] fp.Tuple1[T]

func (r NamedHOfRoot[T]) Name() string {
	return "h"
}
func (r NamedHOfRoot[T]) Value() T {
	return r.I1
}
func (r NamedHOfRoot[T]) Tag() string {
	return ``
}
func (r NamedHOfRoot[T]) WithValue(v T) NamedHOfRoot[T] {
	r.I1 = v
	return r
}

func (r Root) AsLabelled() fp.Labelled8[NamedAOfRoot[int], NamedBOfRoot[string], NamedCOfRoot[float64], NamedDOfRoot[bool], NamedEOfRoot[*int], NamedFOfRoot[[]int], NamedGOfRoot[map[string]int], NamedHOfRoot[Child]] {
	return as.Labelled8(NamedAOfRoot[int]{r.a}, NamedBOfRoot[string]{r.b}, NamedCOfRoot[float64]{r.c}, NamedDOfRoot[bool]{r.d}, NamedEOfRoot[*int]{r.e}, NamedFOfRoot[[]int]{r.f}, NamedGOfRoot[map[string]int]{r.g}, NamedHOfRoot[Child]{r.h})
}

type RootBuilder Root

func (r RootBuilder) Build() Root {
	return Root(r)
}

func (r Root) Builder() RootBuilder {
	return RootBuilder(r)
}

func (r RootBuilder) A(v int) RootBuilder {
	r.a = v
	return r
}

func (r RootBuilder) B(v string) RootBuilder {
	r.b = v
	return r
}

func (r RootBuilder) C(v float64) RootBuilder {
	r.c = v
	return r
}

func (r RootBuilder) D(v bool) RootBuilder {
	r.d = v
	return r
}

func (r RootBuilder) E(v *int) RootBuilder {
	r.e = v
	return r
}

func (r RootBuilder) F(v []int) RootBuilder {
	r.f = v
	return r
}

func (r RootBuilder) G(v map[string]int) RootBuilder {
	r.g = v
	return r
}

func (r RootBuilder) H(v Child) RootBuilder {
	r.h = v
	return r
}

func (r RootBuilder) FromTuple(t fp.Tuple8[int, string, float64, bool, *int, []int, map[string]int, Child]) RootBuilder {
	r.a = t.I1
	r.b = t.I2
	r.c = t.I3
	r.d = t.I4
	r.e = t.I5
	r.f = t.I6
	r.g = t.I7
	r.h = t.I8
	return r
}

func (r RootBuilder) Apply(a int, b string, c float64, d bool, e *int, f []int, g map[string]int, h Child) RootBuilder {
	r.a = a
	r.b = b
	r.c = c
	r.d = d
	r.e = e
	r.f = f
	r.g = g
	r.h = h
	return r
}

func (r RootBuilder) FromMap(m map[string]any) RootBuilder {

	if v, ok := m["a"].(int); ok {
		r.a = v
	}

	if v, ok := m["b"].(string); ok {
		r.b = v
	}

	if v, ok := m["c"].(float64); ok {
		r.c = v
	}

	if v, ok := m["d"].(bool); ok {
		r.d = v
	}

	if v, ok := m["e"].(*int); ok {
		r.e = v
	}

	if v, ok := m["f"].([]int); ok {
		r.f = v
	}

	if v, ok := m["g"].(map[string]int); ok {
		r.g = v
	}

	if v, ok := m["h"].(Child); ok {
		r.h = v
	}

	return r
}

func (r RootBuilder) FromLabelled(t fp.Labelled8[NamedAOfRoot[int], NamedBOfRoot[string], NamedCOfRoot[float64], NamedDOfRoot[bool], NamedEOfRoot[*int], NamedFOfRoot[[]int], NamedGOfRoot[map[string]int], NamedHOfRoot[Child]]) RootBuilder {
	r.a = t.I1.Value()
	r.b = t.I2.Value()
	r.c = t.I3.Value()
	r.d = t.I4.Value()
	r.e = t.I5.Value()
	r.f = t.I6.Value()
	r.g = t.I7.Value()
	r.h = t.I8.Value()
	return r
}

type RootMutable struct {
	A int
	B string
	C float64
	D bool
	E *int
	F []int
	G map[string]int
	H Child
}

func (r Root) AsMutable() RootMutable {
	return RootMutable{
		A: r.a,
		B: r.b,
		C: r.c,
		D: r.d,
		E: r.e,
		F: r.f,
		G: r.g,
		H: r.h,
	}
}

func (r RootMutable) AsImmutable() Root {
	return Root{
		a: r.A,
		b: r.B,
		c: r.C,
		d: r.D,
		e: r.E,
		f: r.F,
		g: r.G,
		h: r.H,
	}
}

func (r Child) A() map[string]any {
	return r.a
}

func (r Child) B() any {
	return r.b
}

func (r Child) WithA(v map[string]any) Child {
	r.a = v
	return r
}

func (r Child) WithB(v any) Child {
	r.b = v
	return r
}

func (r Child) String() string {
	return fmt.Sprintf("testjson.Child{a:%v, b:%v}", r.a, r.b)
}

func (r Child) AsTuple() fp.Tuple2[map[string]any, any] {
	return as.Tuple2(r.a, r.b)
}

func (r Child) Unapply() (map[string]any, any) {
	return r.a, r.b
}

func (r Child) AsMap() map[string]any {
	m := map[string]any{}
	m["a"] = r.a
	m["b"] = r.b
	return m
}

type NamedAOfChild[T any] fp.Tuple1[T]

func (r NamedAOfChild[T]) Name() string {
	return "a"
}
func (r NamedAOfChild[T]) Value() T {
	return r.I1
}
func (r NamedAOfChild[T]) Tag() string {
	return ``
}
func (r NamedAOfChild[T]) WithValue(v T) NamedAOfChild[T] {
	r.I1 = v
	return r
}

type NamedBOfChild[T any] fp.Tuple1[T]

func (r NamedBOfChild[T]) Name() string {
	return "b"
}
func (r NamedBOfChild[T]) Value() T {
	return r.I1
}
func (r NamedBOfChild[T]) Tag() string {
	return ``
}
func (r NamedBOfChild[T]) WithValue(v T) NamedBOfChild[T] {
	r.I1 = v
	return r
}

func (r Child) AsLabelled() fp.Labelled2[NamedAOfChild[map[string]any], NamedBOfChild[any]] {
	return as.Labelled2(NamedAOfChild[map[string]any]{r.a}, NamedBOfChild[any]{r.b})
}

type ChildBuilder Child

func (r ChildBuilder) Build() Child {
	return Child(r)
}

func (r Child) Builder() ChildBuilder {
	return ChildBuilder(r)
}

func (r ChildBuilder) A(v map[string]any) ChildBuilder {
	r.a = v
	return r
}

func (r ChildBuilder) B(v any) ChildBuilder {
	r.b = v
	return r
}

func (r ChildBuilder) FromTuple(t fp.Tuple2[map[string]any, any]) ChildBuilder {
	r.a = t.I1
	r.b = t.I2
	return r
}

func (r ChildBuilder) Apply(a map[string]any, b any) ChildBuilder {
	r.a = a
	r.b = b
	return r
}

func (r ChildBuilder) FromMap(m map[string]any) ChildBuilder {

	if v, ok := m["a"].(map[string]any); ok {
		r.a = v
	}

	if v, ok := m["b"].(any); ok {
		r.b = v
	}

	return r
}

func (r ChildBuilder) FromLabelled(t fp.Labelled2[NamedAOfChild[map[string]any], NamedBOfChild[any]]) ChildBuilder {
	r.a = t.I1.Value()
	r.b = t.I2.Value()
	return r
}

type ChildMutable struct {
	A map[string]any
	B any
}

func (r Child) AsMutable() ChildMutable {
	return ChildMutable{
		A: r.a,
		B: r.b,
	}
}

func (r ChildMutable) AsImmutable() Child {
	return Child{
		a: r.A,
		b: r.B,
	}
}

func (r Node) Name() string {
	return r.name
}

func (r Node) Left() *Node {
	return r.left
}

func (r Node) Right() *Node {
	return r.right
}

func (r Node) WithName(v string) Node {
	r.name = v
	return r
}

func (r Node) WithLeft(v *Node) Node {
	r.left = v
	return r
}

func (r Node) WithRight(v *Node) Node {
	r.right = v
	return r
}

func (r Node) String() string {
	return fmt.Sprintf("testjson.Node{name:%v, left:%v, right:%v}", r.name, r.left, r.right)
}

func (r Node) AsTuple() fp.Tuple3[string, *Node, *Node] {
	return as.Tuple3(r.name, r.left, r.right)
}

func (r Node) Unapply() (string, *Node, *Node) {
	return r.name, r.left, r.right
}

func (r Node) AsMap() map[string]any {
	m := map[string]any{}
	m["name"] = r.name
	m["left"] = r.left
	m["right"] = r.right
	return m
}

type NamedNameOfNode[T any] fp.Tuple1[T]

func (r NamedNameOfNode[T]) Name() string {
	return "name"
}
func (r NamedNameOfNode[T]) Value() T {
	return r.I1
}
func (r NamedNameOfNode[T]) Tag() string {
	return ``
}
func (r NamedNameOfNode[T]) WithValue(v T) NamedNameOfNode[T] {
	r.I1 = v
	return r
}

type NamedLeftOfNode[T any] fp.Tuple1[T]

func (r NamedLeftOfNode[T]) Name() string {
	return "left"
}
func (r NamedLeftOfNode[T]) Value() T {
	return r.I1
}
func (r NamedLeftOfNode[T]) Tag() string {
	return ``
}
func (r NamedLeftOfNode[T]) WithValue(v T) NamedLeftOfNode[T] {
	r.I1 = v
	return r
}

type NamedRightOfNode[T any] fp.Tuple1[T]

func (r NamedRightOfNode[T]) Name() string {
	return "right"
}
func (r NamedRightOfNode[T]) Value() T {
	return r.I1
}
func (r NamedRightOfNode[T]) Tag() string {
	return ``
}
func (r NamedRightOfNode[T]) WithValue(v T) NamedRightOfNode[T] {
	r.I1 = v
	return r
}

func (r Node) AsLabelled() fp.Labelled3[NamedNameOfNode[string], NamedLeftOfNode[*Node], NamedRightOfNode[*Node]] {
	return as.Labelled3(NamedNameOfNode[string]{r.name}, NamedLeftOfNode[*Node]{r.left}, NamedRightOfNode[*Node]{r.right})
}

type NodeBuilder Node

func (r NodeBuilder) Build() Node {
	return Node(r)
}

func (r Node) Builder() NodeBuilder {
	return NodeBuilder(r)
}

func (r NodeBuilder) Name(v string) NodeBuilder {
	r.name = v
	return r
}

func (r NodeBuilder) Left(v *Node) NodeBuilder {
	r.left = v
	return r
}

func (r NodeBuilder) Right(v *Node) NodeBuilder {
	r.right = v
	return r
}

func (r NodeBuilder) FromTuple(t fp.Tuple3[string, *Node, *Node]) NodeBuilder {
	r.name = t.I1
	r.left = t.I2
	r.right = t.I3
	return r
}

func (r NodeBuilder) Apply(name string, left *Node, right *Node) NodeBuilder {
	r.name = name
	r.left = left
	r.right = right
	return r
}

func (r NodeBuilder) FromMap(m map[string]any) NodeBuilder {

	if v, ok := m["name"].(string); ok {
		r.name = v
	}

	if v, ok := m["left"].(*Node); ok {
		r.left = v
	}

	if v, ok := m["right"].(*Node); ok {
		r.right = v
	}

	return r
}

func (r NodeBuilder) FromLabelled(t fp.Labelled3[NamedNameOfNode[string], NamedLeftOfNode[*Node], NamedRightOfNode[*Node]]) NodeBuilder {
	r.name = t.I1.Value()
	r.left = t.I2.Value()
	r.right = t.I3.Value()
	return r
}

type NodeMutable struct {
	Name  string
	Left  *Node
	Right *Node
}

func (r Node) AsMutable() NodeMutable {
	return NodeMutable{
		Name:  r.name,
		Left:  r.left,
		Right: r.right,
	}
}

func (r NodeMutable) AsImmutable() Node {
	return Node{
		name:  r.Name,
		left:  r.Left,
		right: r.Right,
	}
}

func (r Tree) Root() *Node {
	return r.root
}

func (r Tree) WithRoot(v *Node) Tree {
	r.root = v
	return r
}

func (r Tree) String() string {
	return fmt.Sprintf("testjson.Tree{root:%v}", r.root)
}

func (r Tree) AsTuple() fp.Tuple1[*Node] {
	return as.Tuple1(r.root)
}

func (r Tree) Unapply() *Node {
	return r.root
}

func (r Tree) AsMap() map[string]any {
	m := map[string]any{}
	m["root"] = r.root
	return m
}

type NamedRootOfTree[T any] fp.Tuple1[T]

func (r NamedRootOfTree[T]) Name() string {
	return "root"
}
func (r NamedRootOfTree[T]) Value() T {
	return r.I1
}
func (r NamedRootOfTree[T]) Tag() string {
	return ``
}
func (r NamedRootOfTree[T]) WithValue(v T) NamedRootOfTree[T] {
	r.I1 = v
	return r
}

func (r Tree) AsLabelled() fp.Labelled1[NamedRootOfTree[*Node]] {
	return as.Labelled1(NamedRootOfTree[*Node]{r.root})
}

type TreeBuilder Tree

func (r TreeBuilder) Build() Tree {
	return Tree(r)
}

func (r Tree) Builder() TreeBuilder {
	return TreeBuilder(r)
}

func (r TreeBuilder) Root(v *Node) TreeBuilder {
	r.root = v
	return r
}

func (r TreeBuilder) FromTuple(t fp.Tuple1[*Node]) TreeBuilder {
	r.root = t.I1
	return r
}

func (r TreeBuilder) Apply(root *Node) TreeBuilder {
	r.root = root
	return r
}

func (r TreeBuilder) FromMap(m map[string]any) TreeBuilder {

	if v, ok := m["root"].(*Node); ok {
		r.root = v
	}

	return r
}

func (r TreeBuilder) FromLabelled(t fp.Labelled1[NamedRootOfTree[*Node]]) TreeBuilder {
	r.root = t.I1.Value()
	return r
}

type TreeMutable struct {
	Root *Node
}

func (r Tree) AsMutable() TreeMutable {
	return TreeMutable{
		Root: r.root,
	}
}

func (r TreeMutable) AsImmutable() Tree {
	return Tree{
		root: r.Root,
	}
}

func (r Entry[V]) Name() string {
	return r.name
}

func (r Entry[V]) Value() V {
	return r.value
}

func (r Entry[V]) WithName(v string) Entry[V] {
	r.name = v
	return r
}

func (r Entry[V]) WithValue(v V) Entry[V] {
	r.value = v
	return r
}

func (r Entry[V]) String() string {
	return fmt.Sprintf("testjson.Entry{name:%v, value:%v}", r.name, r.value)
}

func (r Entry[V]) AsTuple() fp.Tuple2[string, V] {
	return as.Tuple2(r.name, r.value)
}

func (r Entry[V]) Unapply() (string, V) {
	return r.name, r.value
}

func (r Entry[V]) AsMap() map[string]any {
	m := map[string]any{}
	m["name"] = r.name
	m["value"] = r.value
	return m
}

type NamedNameOfEntry[T any] fp.Tuple1[T]

func (r NamedNameOfEntry[T]) Name() string {
	return "name"
}
func (r NamedNameOfEntry[T]) Value() T {
	return r.I1
}
func (r NamedNameOfEntry[T]) Tag() string {
	return ``
}
func (r NamedNameOfEntry[T]) WithValue(v T) NamedNameOfEntry[T] {
	r.I1 = v
	return r
}

type NamedValueOfEntry[T any] fp.Tuple1[T]

func (r NamedValueOfEntry[T]) Name() string {
	return "value"
}
func (r NamedValueOfEntry[T]) Value() T {
	return r.I1
}
func (r NamedValueOfEntry[T]) Tag() string {
	return ``
}
func (r NamedValueOfEntry[T]) WithValue(v T) NamedValueOfEntry[T] {
	r.I1 = v
	return r
}

func (r Entry[V]) AsLabelled() fp.Labelled2[NamedNameOfEntry[string], NamedValueOfEntry[V]] {
	return as.Labelled2(NamedNameOfEntry[string]{r.name}, NamedValueOfEntry[V]{r.value})
}

type EntryBuilder[V any] Entry[V]

func (r EntryBuilder[V]) Build() Entry[V] {
	return Entry[V](r)
}

func (r Entry[V]) Builder() EntryBuilder[V] {
	return EntryBuilder[V](r)
}

func (r EntryBuilder[V]) Name(v string) EntryBuilder[V] {
	r.name = v
	return r
}

func (r EntryBuilder[V]) Value(v V) EntryBuilder[V] {
	r.value = v
	return r
}

func (r EntryBuilder[V]) FromTuple(t fp.Tuple2[string, V]) EntryBuilder[V] {
	r.name = t.I1
	r.value = t.I2
	return r
}

func (r EntryBuilder[V]) Apply(name string, value V) EntryBuilder[V] {
	r.name = name
	r.value = value
	return r
}

func (r EntryBuilder[V]) FromMap(m map[string]any) EntryBuilder[V] {

	if v, ok := m["name"].(string); ok {
		r.name = v
	}

	if v, ok := m["value"].(V); ok {
		r.value = v
	}

	return r
}

func (r EntryBuilder[V]) FromLabelled(t fp.Labelled2[NamedNameOfEntry[string], NamedValueOfEntry[V]]) EntryBuilder[V] {
	r.name = t.I1.Value()
	r.value = t.I2.Value()
	return r
}

type EntryMutable[V any] struct {
	Name  string
	Value V
}

func (r Entry[V]) AsMutable() EntryMutable[V] {
	return EntryMutable[V]{
		Name:  r.name,
		Value: r.value,
	}
}

func (r EntryMutable[V]) AsImmutable() Entry[V] {
	return Entry[V]{
		name:  r.Name,
		value: r.Value,
	}
}

func (r NotUsedParam[K, V]) Param() string {
	return r.param
}

func (r NotUsedParam[K, V]) Value() V {
	return r.value
}

func (r NotUsedParam[K, V]) WithParam(v string) NotUsedParam[K, V] {
	r.param = v
	return r
}

func (r NotUsedParam[K, V]) WithValue(v V) NotUsedParam[K, V] {
	r.value = v
	return r
}

func (r NotUsedParam[K, V]) String() string {
	return fmt.Sprintf("testjson.NotUsedParam{param:%v, value:%v}", r.param, r.value)
}

func (r NotUsedParam[K, V]) AsTuple() fp.Tuple2[string, V] {
	return as.Tuple2(r.param, r.value)
}

func (r NotUsedParam[K, V]) Unapply() (string, V) {
	return r.param, r.value
}

func (r NotUsedParam[K, V]) AsMap() map[string]any {
	m := map[string]any{}
	m["param"] = r.param
	m["value"] = r.value
	return m
}

type NamedParamOfNotUsedParam[T any] fp.Tuple1[T]

func (r NamedParamOfNotUsedParam[T]) Name() string {
	return "param"
}
func (r NamedParamOfNotUsedParam[T]) Value() T {
	return r.I1
}
func (r NamedParamOfNotUsedParam[T]) Tag() string {
	return ``
}
func (r NamedParamOfNotUsedParam[T]) WithValue(v T) NamedParamOfNotUsedParam[T] {
	r.I1 = v
	return r
}

type NamedValueOfNotUsedParam[T any] fp.Tuple1[T]

func (r NamedValueOfNotUsedParam[T]) Name() string {
	return "value"
}
func (r NamedValueOfNotUsedParam[T]) Value() T {
	return r.I1
}
func (r NamedValueOfNotUsedParam[T]) Tag() string {
	return ``
}
func (r NamedValueOfNotUsedParam[T]) WithValue(v T) NamedValueOfNotUsedParam[T] {
	r.I1 = v
	return r
}

func (r NotUsedParam[K, V]) AsLabelled() fp.Labelled2[NamedParamOfNotUsedParam[string], NamedValueOfNotUsedParam[V]] {
	return as.Labelled2(NamedParamOfNotUsedParam[string]{r.param}, NamedValueOfNotUsedParam[V]{r.value})
}

type NotUsedParamBuilder[K any, V any] NotUsedParam[K, V]

func (r NotUsedParamBuilder[K, V]) Build() NotUsedParam[K, V] {
	return NotUsedParam[K, V](r)
}

func (r NotUsedParam[K, V]) Builder() NotUsedParamBuilder[K, V] {
	return NotUsedParamBuilder[K, V](r)
}

func (r NotUsedParamBuilder[K, V]) Param(v string) NotUsedParamBuilder[K, V] {
	r.param = v
	return r
}

func (r NotUsedParamBuilder[K, V]) Value(v V) NotUsedParamBuilder[K, V] {
	r.value = v
	return r
}

func (r NotUsedParamBuilder[K, V]) FromTuple(t fp.Tuple2[string, V]) NotUsedParamBuilder[K, V] {
	r.param = t.I1
	r.value = t.I2
	return r
}

func (r NotUsedParamBuilder[K, V]) Apply(param string, value V) NotUsedParamBuilder[K, V] {
	r.param = param
	r.value = value
	return r
}

func (r NotUsedParamBuilder[K, V]) FromMap(m map[string]any) NotUsedParamBuilder[K, V] {

	if v, ok := m["param"].(string); ok {
		r.param = v
	}

	if v, ok := m["value"].(V); ok {
		r.value = v
	}

	return r
}

func (r NotUsedParamBuilder[K, V]) FromLabelled(t fp.Labelled2[NamedParamOfNotUsedParam[string], NamedValueOfNotUsedParam[V]]) NotUsedParamBuilder[K, V] {
	r.param = t.I1.Value()
	r.value = t.I2.Value()
	return r
}

type NotUsedParamMutable[K any, V any] struct {
	Param string
	Value V
}

func (r NotUsedParam[K, V]) AsMutable() NotUsedParamMutable[K, V] {
	return NotUsedParamMutable[K, V]{
		Param: r.param,
		Value: r.value,
	}
}

func (r NotUsedParamMutable[K, V]) AsImmutable() NotUsedParam[K, V] {
	return NotUsedParam[K, V]{
		param: r.Param,
		value: r.Value,
	}
}

func (r Movie) Name() string {
	return r.name
}

func (r Movie) Casting() Entry[string] {
	return r.casting
}

func (r Movie) NotUsed() NotUsedParam[int, string] {
	return r.notUsed
}

func (r Movie) WithName(v string) Movie {
	r.name = v
	return r
}

func (r Movie) WithCasting(v Entry[string]) Movie {
	r.casting = v
	return r
}

func (r Movie) WithNotUsed(v NotUsedParam[int, string]) Movie {
	r.notUsed = v
	return r
}

func (r Movie) String() string {
	return fmt.Sprintf("testjson.Movie{name:%v, casting:%v, notUsed:%v}", r.name, r.casting, r.notUsed)
}

func (r Movie) AsTuple() fp.Tuple3[string, Entry[string], NotUsedParam[int, string]] {
	return as.Tuple3(r.name, r.casting, r.notUsed)
}

func (r Movie) Unapply() (string, Entry[string], NotUsedParam[int, string]) {
	return r.name, r.casting, r.notUsed
}

func (r Movie) AsMap() map[string]any {
	m := map[string]any{}
	m["name"] = r.name
	m["casting"] = r.casting
	m["notUsed"] = r.notUsed
	return m
}

type NamedNameOfMovie[T any] fp.Tuple1[T]

func (r NamedNameOfMovie[T]) Name() string {
	return "name"
}
func (r NamedNameOfMovie[T]) Value() T {
	return r.I1
}
func (r NamedNameOfMovie[T]) Tag() string {
	return ``
}
func (r NamedNameOfMovie[T]) WithValue(v T) NamedNameOfMovie[T] {
	r.I1 = v
	return r
}

type NamedCastingOfMovie[T any] fp.Tuple1[T]

func (r NamedCastingOfMovie[T]) Name() string {
	return "casting"
}
func (r NamedCastingOfMovie[T]) Value() T {
	return r.I1
}
func (r NamedCastingOfMovie[T]) Tag() string {
	return ``
}
func (r NamedCastingOfMovie[T]) WithValue(v T) NamedCastingOfMovie[T] {
	r.I1 = v
	return r
}

type NamedNotUsedOfMovie[T any] fp.Tuple1[T]

func (r NamedNotUsedOfMovie[T]) Name() string {
	return "notUsed"
}
func (r NamedNotUsedOfMovie[T]) Value() T {
	return r.I1
}
func (r NamedNotUsedOfMovie[T]) Tag() string {
	return ``
}
func (r NamedNotUsedOfMovie[T]) WithValue(v T) NamedNotUsedOfMovie[T] {
	r.I1 = v
	return r
}

func (r Movie) AsLabelled() fp.Labelled3[NamedNameOfMovie[string], NamedCastingOfMovie[Entry[string]], NamedNotUsedOfMovie[NotUsedParam[int, string]]] {
	return as.Labelled3(NamedNameOfMovie[string]{r.name}, NamedCastingOfMovie[Entry[string]]{r.casting}, NamedNotUsedOfMovie[NotUsedParam[int, string]]{r.notUsed})
}

type MovieBuilder Movie

func (r MovieBuilder) Build() Movie {
	return Movie(r)
}

func (r Movie) Builder() MovieBuilder {
	return MovieBuilder(r)
}

func (r MovieBuilder) Name(v string) MovieBuilder {
	r.name = v
	return r
}

func (r MovieBuilder) Casting(v Entry[string]) MovieBuilder {
	r.casting = v
	return r
}

func (r MovieBuilder) NotUsed(v NotUsedParam[int, string]) MovieBuilder {
	r.notUsed = v
	return r
}

func (r MovieBuilder) FromTuple(t fp.Tuple3[string, Entry[string], NotUsedParam[int, string]]) MovieBuilder {
	r.name = t.I1
	r.casting = t.I2
	r.notUsed = t.I3
	return r
}

func (r MovieBuilder) Apply(name string, casting Entry[string], notUsed NotUsedParam[int, string]) MovieBuilder {
	r.name = name
	r.casting = casting
	r.notUsed = notUsed
	return r
}

func (r MovieBuilder) FromMap(m map[string]any) MovieBuilder {

	if v, ok := m["name"].(string); ok {
		r.name = v
	}

	if v, ok := m["casting"].(Entry[string]); ok {
		r.casting = v
	}

	if v, ok := m["notUsed"].(NotUsedParam[int, string]); ok {
		r.notUsed = v
	}

	return r
}

func (r MovieBuilder) FromLabelled(t fp.Labelled3[NamedNameOfMovie[string], NamedCastingOfMovie[Entry[string]], NamedNotUsedOfMovie[NotUsedParam[int, string]]]) MovieBuilder {
	r.name = t.I1.Value()
	r.casting = t.I2.Value()
	r.notUsed = t.I3.Value()
	return r
}

type MovieMutable struct {
	Name    string
	Casting Entry[string]
	NotUsed NotUsedParam[int, string]
}

func (r Movie) AsMutable() MovieMutable {
	return MovieMutable{
		Name:    r.name,
		Casting: r.casting,
		NotUsed: r.notUsed,
	}
}

func (r MovieMutable) AsImmutable() Movie {
	return Movie{
		name:    r.Name,
		casting: r.Casting,
		notUsed: r.NotUsed,
	}
}

func (r NoPrivate) String() string {
	return fmt.Sprintf("testjson.NoPrivate{Root:%v}", r.Root)
}

func (r NoPrivate) AsTuple() fp.Tuple1[string] {
	return as.Tuple1(r.Root)
}

func (r NoPrivate) Unapply() string {
	return r.Root
}

func (r NoPrivate) AsMap() map[string]any {
	m := map[string]any{}
	m["Root"] = r.Root
	return m
}

type PubNamedRootOfNoPrivate[T any] fp.Tuple1[T]

func (r PubNamedRootOfNoPrivate[T]) Name() string {
	return "Root"
}
func (r PubNamedRootOfNoPrivate[T]) Value() T {
	return r.I1
}
func (r PubNamedRootOfNoPrivate[T]) Tag() string {
	return ``
}
func (r PubNamedRootOfNoPrivate[T]) WithValue(v T) PubNamedRootOfNoPrivate[T] {
	r.I1 = v
	return r
}

func (r NoPrivate) AsLabelled() fp.Labelled1[PubNamedRootOfNoPrivate[string]] {
	return as.Labelled1(PubNamedRootOfNoPrivate[string]{r.Root})
}

type NoPrivateBuilder NoPrivate

func (r NoPrivateBuilder) Build() NoPrivate {
	return NoPrivate(r)
}

func (r NoPrivate) Builder() NoPrivateBuilder {
	return NoPrivateBuilder(r)
}

func (r NoPrivateBuilder) FromTuple(t fp.Tuple1[string]) NoPrivateBuilder {
	r.Root = t.I1
	return r
}

func (r NoPrivateBuilder) Apply(Root string) NoPrivateBuilder {
	r.Root = Root
	return r
}

func (r NoPrivateBuilder) FromMap(m map[string]any) NoPrivateBuilder {

	if v, ok := m["Root"].(string); ok {
		r.Root = v
	}

	return r
}

func (r NoPrivateBuilder) FromLabelled(t fp.Labelled1[PubNamedRootOfNoPrivate[string]]) NoPrivateBuilder {
	r.Root = t.I1.Value()
	return r
}

type NoPrivateMutable struct {
	Root string
}

func (r NoPrivate) AsMutable() NoPrivateMutable {
	return NoPrivateMutable{
		Root: r.Root,
	}
}

func (r NoPrivateMutable) AsImmutable() NoPrivate {
	return NoPrivate{
		Root: r.Root,
	}
}
