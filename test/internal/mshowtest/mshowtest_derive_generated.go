// Code generated by gombok, DO NOT EDIT.
package mshowtest

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
	"github.com/csgura/fp/hlist"
	"github.com/csgura/fp/lazy"
	"github.com/csgura/fp/mshow"
	"github.com/csgura/fp/product"
	"github.com/csgura/fp/test/internal/recursive"
)

func ShowPerson() mshow.Show[Person] {
	return mshow.Generic(
		as.Generic(
			"mshowtest.Person",
			"Struct",
			func(v Person) fp.Tuple2[string, int] {
				return as.Tuple2(v.Name, v.Age)
			},
			func(t fp.Tuple2[string, int]) Person {
				return Person{
					Name: t.I1,
					Age:  t.I2,
				}
			},
		),
		mshow.Struct2([]fp.Named{as.NameTag(`Name`, ``), as.NameTag(`Age`, ``)}, mshow.String, mshow.Int[int]()),
	)
}

func ShowCollection() mshow.Show[Collection] {
	return mshow.Generic(
		as.Generic(
			"mshowtest.Collection",
			"Struct",
			func(v Collection) fp.Tuple11[map[string]Person, []Person, *string, fp.Set[int], fp.Option[Person], NoDerive, HasStringMethod, *bool, map[string]NoDerive, recursive.StringAlias, fp.Seq[string]] {
				return as.Tuple11(v.Index, v.List, v.Description, v.Set, v.Option, v.NoDerive, v.Stringer, v.BoolPtr, v.NoMap, v.Alias, v.StringSeq)
			},
			func(t fp.Tuple11[map[string]Person, []Person, *string, fp.Set[int], fp.Option[Person], NoDerive, HasStringMethod, *bool, map[string]NoDerive, recursive.StringAlias, fp.Seq[string]]) Collection {
				return Collection{
					Index:       t.I1,
					List:        t.I2,
					Description: t.I3,
					Set:         t.I4,
					Option:      t.I5,
					NoDerive:    t.I6,
					Stringer:    t.I7,
					BoolPtr:     t.I8,
					NoMap:       t.I9,
					Alias:       t.I10,
					StringSeq:   t.I11,
				}
			},
		),
		mshow.Struct11([]fp.Named{as.NameTag(`Index`, ``), as.NameTag(`List`, ``), as.NameTag(`Description`, ``), as.NameTag(`Set`, ``), as.NameTag(`Option`, ``), as.NameTag(`NoDerive`, ``), as.NameTag(`Stringer`, ``), as.NameTag(`BoolPtr`, ``), as.NameTag(`NoMap`, ``), as.NameTag(`Alias`, ``), as.NameTag(`StringSeq`, ``)}, mshow.GoMap(mshow.String, ShowPerson()), mshow.Slice(ShowPerson()), mshow.Ptr(lazy.Call(func() mshow.Show[string] {
			return mshow.String
		})), mshow.Set(mshow.Int[int]()), mshow.Option(ShowPerson()), ShowNoDerive(), mshow.Given[HasStringMethod](), mshow.Ptr(lazy.Call(func() mshow.Show[bool] {
			return mshow.Bool
		})), mshow.GoMap(mshow.String, ShowNoDerive()), ShowRecursiveStringAlias(), mshow.Seq(mshow.String)),
	)
}

func ShowDupGenerate() mshow.Show[DupGenerate] {
	return mshow.Generic(
		as.Generic(
			"mshowtest.DupGenerate",
			"Struct",
			func(v DupGenerate) fp.Tuple2[NoDerive, string] {
				return as.Tuple2(v.NoDerive, v.World)
			},
			func(t fp.Tuple2[NoDerive, string]) DupGenerate {
				return DupGenerate{
					NoDerive: t.I1,
					World:    t.I2,
				}
			},
		),
		mshow.Struct2([]fp.Named{as.NameTag(`NoDerive`, ``), as.NameTag(`World`, ``)}, ShowNoDerive(), mshow.String),
	)
}

func ShowHasTuple() mshow.Show[HasTuple] {
	return mshow.Generic(
		as.Generic(
			"mshowtest.HasTuple",
			"Struct",
			func(v HasTuple) fp.Tuple2[fp.Tuple2[string, int], hlist.Cons[string, hlist.Cons[int, hlist.Nil]]] {
				return as.Tuple2(v.Entry, v.HList)
			},
			func(t fp.Tuple2[fp.Tuple2[string, int], hlist.Cons[string, hlist.Cons[int, hlist.Nil]]]) HasTuple {
				return HasTuple{
					Entry: t.I1,
					HList: t.I2,
				}
			},
		),
		mshow.Struct2([]fp.Named{as.NameTag(`Entry`, ``), as.NameTag(`HList`, ``)}, mshow.Generic(
			as.Generic(
				"fp.Tuple2",
				"Tuple",
				as.HList2,
				product.TupleFromHList2[string, int],
			),
			mshow.TupleHCons(
				mshow.String,
				mshow.TupleHCons(
					mshow.Int[int](),
					mshow.HNil,
				),
			),
		), mshow.HCons(mshow.String, mshow.HCons(mshow.Int[int](), mshow.HNil))),
	)
}

func ShowEmbeddedStruct() mshow.Show[EmbeddedStruct] {
	return mshow.Generic(
		as.Generic(
			"mshowtest.EmbeddedStruct",
			"Struct",
			EmbeddedStruct.AsTuple,
			fp.Compose(
				as.Curried2(EmbeddedStructBuilder.FromTuple)(EmbeddedStructBuilder{}),
				EmbeddedStructBuilder.Build,
			),
		),
		mshow.Struct2([]fp.Named{as.NameTag(`hello`, ``), as.NameTag(`world`, ``)}, mshow.String, mshow.Generic(
			as.Generic(
				"struct",
				"Struct",
				func(v struct {
					Level int
					Stage string
				}) fp.Tuple2[int, string] {
					return as.Tuple2(v.Level, v.Stage)
				},
				func(t fp.Tuple2[int, string]) struct {
					Level int
					Stage string
				} {
					return struct {
						Level int
						Stage string
					}{
						Level: t.I1,
						Stage: t.I2,
					}
				},
			),
			mshow.Struct2([]fp.Named{as.NameTag(`Level`, ``), as.NameTag(`Stage`, ``)}, mshow.Int[int](), mshow.String),
		)),
	)
}

func ShowEmbeddedTypeParamStruct[T any](showT mshow.Show[T]) mshow.Show[EmbeddedTypeParamStruct[T]] {
	return mshow.Generic(
		as.Generic(
			"mshowtest.EmbeddedTypeParamStruct",
			"Struct",
			EmbeddedTypeParamStruct[T].AsTuple,
			fp.Compose(
				as.Curried2(EmbeddedTypeParamStructBuilder[T].FromTuple)(EmbeddedTypeParamStructBuilder[T]{}),
				EmbeddedTypeParamStructBuilder[T].Build,
			),
		),
		mshow.Struct2([]fp.Named{as.NameTag(`hello`, ``), as.NameTag(`world`, ``)}, mshow.String, mshow.Generic(
			as.Generic(
				"struct",
				"Struct",
				func(v struct {
					Level T
					Stage string
				}) fp.Tuple2[T, string] {
					return as.Tuple2(v.Level, v.Stage)
				},
				func(t fp.Tuple2[T, string]) struct {
					Level T
					Stage string
				} {
					return struct {
						Level T
						Stage string
					}{
						Level: t.I1,
						Stage: t.I2,
					}
				},
			),
			mshow.Struct2([]fp.Named{as.NameTag(`Level`, ``), as.NameTag(`Stage`, ``)}, showT, mshow.String),
		)),
	)
}

func ShowNoDerive() mshow.Show[NoDerive] {
	return mshow.Generic(
		as.Generic(
			"mshowtest.NoDerive",
			"Struct",
			fp.Compose(
				func(v NoDerive) fp.Labelled1[fp.RuntimeNamed[string]] {
					i0 := v.Hello
					return as.Labelled1(as.NamedWithTag("Hello", i0, ``))
				},
				as.HList1Labelled,
			),

			fp.Compose(
				product.LabelledFromHList1,
				func(t fp.Labelled1[fp.RuntimeNamed[string]]) NoDerive {
					return NoDerive{Hello: t.I1.Value()}
				},
			),
		),
		mshow.HConsLabelled(
			mshow.Given[fp.RuntimeNamed[string]](),
			mshow.HNil,
		),
	)
}

func ShowRecursiveStringAlias() mshow.Show[recursive.StringAlias] {
	return mshow.Generic(
		as.Generic(
			"recursive.StringAlias",
			"NewType",
			func(v recursive.StringAlias) string {
				return string(v)
			},
			func(v string) recursive.StringAlias {
				return recursive.StringAlias(v)
			},
		),
		mshow.String,
	)
}
