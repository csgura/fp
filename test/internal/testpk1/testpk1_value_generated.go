// Code generated by gombok, DO NOT EDIT.
package testpk1

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
	"github.com/csgura/fp/option"
	"net/http"
	"time"
)

func (r World) Message() string {
	return r.message
}

func (r World) Timestamp() time.Time {
	return r.timestamp
}

func (r World) WithMessage(v string) World {
	r.message = v
	return r
}

func (r World) WithTimestamp(v time.Time) World {
	r.timestamp = v
	return r
}

func (r World) String() string {
	return fmt.Sprintf("testpk1.World{message:%v, timestamp:%v, Pub:%v}", r.message, r.timestamp, r.Pub)
}

func (r World) AsTuple() fp.Tuple3[string, time.Time, string] {
	return as.Tuple3(r.message, r.timestamp, r.Pub)
}

func (r World) Unapply() (string, time.Time, string) {
	return r.message, r.timestamp, r.Pub
}

func (r World) AsMap() map[string]any {
	m := map[string]any{}
	m["message"] = r.message
	m["timestamp"] = r.timestamp
	m["Pub"] = r.Pub
	return m
}

type NamedMessageOfWorld[T any] fp.Tuple1[T]

func (r NamedMessageOfWorld[T]) Name() string {
	return "message"
}
func (r NamedMessageOfWorld[T]) Value() T {
	return r.I1
}
func (r NamedMessageOfWorld[T]) Tag() string {
	return `hello:"message"`
}
func (r NamedMessageOfWorld[T]) WithValue(v T) NamedMessageOfWorld[T] {
	r.I1 = v
	return r
}

type NamedTimestampOfWorld[T any] fp.Tuple1[T]

func (r NamedTimestampOfWorld[T]) Name() string {
	return "timestamp"
}
func (r NamedTimestampOfWorld[T]) Value() T {
	return r.I1
}
func (r NamedTimestampOfWorld[T]) Tag() string {
	return ``
}
func (r NamedTimestampOfWorld[T]) WithValue(v T) NamedTimestampOfWorld[T] {
	r.I1 = v
	return r
}

type PubNamedPubOfWorld[T any] fp.Tuple1[T]

func (r PubNamedPubOfWorld[T]) Name() string {
	return "Pub"
}
func (r PubNamedPubOfWorld[T]) Value() T {
	return r.I1
}
func (r PubNamedPubOfWorld[T]) Tag() string {
	return ``
}
func (r PubNamedPubOfWorld[T]) WithValue(v T) PubNamedPubOfWorld[T] {
	r.I1 = v
	return r
}

func (r World) AsLabelled() fp.Labelled3[NamedMessageOfWorld[string], NamedTimestampOfWorld[time.Time], PubNamedPubOfWorld[string]] {
	return as.Labelled3(NamedMessageOfWorld[string]{r.message}, NamedTimestampOfWorld[time.Time]{r.timestamp}, PubNamedPubOfWorld[string]{r.Pub})
}

func (r World) MarshalJSON() ([]byte, error) {
	m := r.AsMutable()
	return json.Marshal(m)
}

func (r *World) UnmarshalJSON(b []byte) error {
	if r == nil {
		return fp.Error(http.StatusBadRequest, "target ptr is nil")
	}
	m := r.AsMutable()
	err := json.Unmarshal(b, &m)
	if err == nil {
		*r = m.AsImmutable()
	}
	return err
}

type WorldBuilder World

func (r WorldBuilder) Build() World {
	return World(r)
}

func (r World) Builder() WorldBuilder {
	return WorldBuilder(r)
}

func (r WorldBuilder) Message(v string) WorldBuilder {
	r.message = v
	return r
}

func (r WorldBuilder) Timestamp(v time.Time) WorldBuilder {
	r.timestamp = v
	return r
}

func (r WorldBuilder) FromTuple(t fp.Tuple3[string, time.Time, string]) WorldBuilder {
	r.message = t.I1
	r.timestamp = t.I2
	r.Pub = t.I3
	return r
}

func (r WorldBuilder) Apply(message string, timestamp time.Time, Pub string) WorldBuilder {
	r.message = message
	r.timestamp = timestamp
	r.Pub = Pub
	return r
}

func (r WorldBuilder) FromMap(m map[string]any) WorldBuilder {

	if v, ok := m["message"].(string); ok {
		r.message = v
	}

	if v, ok := m["timestamp"].(time.Time); ok {
		r.timestamp = v
	}

	if v, ok := m["Pub"].(string); ok {
		r.Pub = v
	}

	return r
}

func (r WorldBuilder) FromLabelled(t fp.Labelled3[NamedMessageOfWorld[string], NamedTimestampOfWorld[time.Time], PubNamedPubOfWorld[string]]) WorldBuilder {
	r.message = t.I1.Value()
	r.timestamp = t.I2.Value()
	r.Pub = t.I3.Value()
	return r
}

type WorldMutable struct {
	Message    string    `hello:"message" json:"message,omitempty"`
	Timestamp  time.Time `json:"timestamp"`
	Pub        string    `json:"Pub,omitempty"`
	_notExport string
}

func (r World) AsMutable() WorldMutable {
	return WorldMutable{
		Message:   r.message,
		Timestamp: r.timestamp,
		Pub:       r.Pub,
	}
}

func (r WorldMutable) AsImmutable() World {
	return World{
		message:   r.Message,
		timestamp: r.Timestamp,
		Pub:       r.Pub,
	}
}

func (r HasOption) Message() string {
	return r.message
}

func (r HasOption) Addr() fp.Option[string] {
	return r.addr
}

func (r HasOption) Phone() []string {
	return r.phone
}

func (r HasOption) EmptySeq() []int {
	return r.emptySeq
}

func (r HasOption) WithMessage(v string) HasOption {
	r.message = v
	return r
}

func (r HasOption) WithAddr(v fp.Option[string]) HasOption {
	r.addr = v
	return r
}

func (r HasOption) WithSomeAddr(v string) HasOption {
	r.addr = option.Some(v)
	return r
}

func (r HasOption) WithNoneAddr() HasOption {
	r.addr = option.None[string]()
	return r
}

func (r HasOption) WithPhone(v []string) HasOption {
	r.phone = v
	return r
}

func (r HasOption) WithEmptySeq(v []int) HasOption {
	r.emptySeq = v
	return r
}

func (r HasOption) String() string {
	return fmt.Sprintf("testpk1.HasOption{message:%v, addr:%v, phone:%v, emptySeq:%v}", r.message, r.addr, r.phone, r.emptySeq)
}

func (r HasOption) AsTuple() fp.Tuple4[string, fp.Option[string], []string, []int] {
	return as.Tuple4(r.message, r.addr, r.phone, r.emptySeq)
}

func (r HasOption) Unapply() (string, fp.Option[string], []string, []int) {
	return r.message, r.addr, r.phone, r.emptySeq
}

func (r HasOption) AsMap() map[string]any {
	m := map[string]any{}
	m["message"] = r.message
	if r.addr.IsDefined() {
		m["addr"] = r.addr.Get()
	}
	m["phone"] = r.phone
	m["emptySeq"] = r.emptySeq
	return m
}

type NamedMessageOfHasOption[T any] fp.Tuple1[T]

func (r NamedMessageOfHasOption[T]) Name() string {
	return "message"
}
func (r NamedMessageOfHasOption[T]) Value() T {
	return r.I1
}
func (r NamedMessageOfHasOption[T]) Tag() string {
	return ``
}
func (r NamedMessageOfHasOption[T]) WithValue(v T) NamedMessageOfHasOption[T] {
	r.I1 = v
	return r
}

type NamedAddrOfHasOption[T any] fp.Tuple1[T]

func (r NamedAddrOfHasOption[T]) Name() string {
	return "addr"
}
func (r NamedAddrOfHasOption[T]) Value() T {
	return r.I1
}
func (r NamedAddrOfHasOption[T]) Tag() string {
	return ``
}
func (r NamedAddrOfHasOption[T]) WithValue(v T) NamedAddrOfHasOption[T] {
	r.I1 = v
	return r
}

type NamedPhoneOfHasOption[T any] fp.Tuple1[T]

func (r NamedPhoneOfHasOption[T]) Name() string {
	return "phone"
}
func (r NamedPhoneOfHasOption[T]) Value() T {
	return r.I1
}
func (r NamedPhoneOfHasOption[T]) Tag() string {
	return ``
}
func (r NamedPhoneOfHasOption[T]) WithValue(v T) NamedPhoneOfHasOption[T] {
	r.I1 = v
	return r
}

type NamedEmptySeqOfHasOption[T any] fp.Tuple1[T]

func (r NamedEmptySeqOfHasOption[T]) Name() string {
	return "emptySeq"
}
func (r NamedEmptySeqOfHasOption[T]) Value() T {
	return r.I1
}
func (r NamedEmptySeqOfHasOption[T]) Tag() string {
	return ``
}
func (r NamedEmptySeqOfHasOption[T]) WithValue(v T) NamedEmptySeqOfHasOption[T] {
	r.I1 = v
	return r
}

func (r HasOption) AsLabelled() fp.Labelled4[NamedMessageOfHasOption[string], NamedAddrOfHasOption[fp.Option[string]], NamedPhoneOfHasOption[[]string], NamedEmptySeqOfHasOption[[]int]] {
	return as.Labelled4(NamedMessageOfHasOption[string]{r.message}, NamedAddrOfHasOption[fp.Option[string]]{r.addr}, NamedPhoneOfHasOption[[]string]{r.phone}, NamedEmptySeqOfHasOption[[]int]{r.emptySeq})
}

type HasOptionBuilder HasOption

func (r HasOptionBuilder) Build() HasOption {
	return HasOption(r)
}

func (r HasOption) Builder() HasOptionBuilder {
	return HasOptionBuilder(r)
}

func (r HasOptionBuilder) Message(v string) HasOptionBuilder {
	r.message = v
	return r
}

func (r HasOptionBuilder) Addr(v fp.Option[string]) HasOptionBuilder {
	r.addr = v
	return r
}

func (r HasOptionBuilder) SomeAddr(v string) HasOptionBuilder {
	r.addr = option.Some(v)
	return r
}

func (r HasOptionBuilder) NoneAddr() HasOptionBuilder {
	r.addr = option.None[string]()
	return r
}

func (r HasOptionBuilder) Phone(v []string) HasOptionBuilder {
	r.phone = v
	return r
}

func (r HasOptionBuilder) EmptySeq(v []int) HasOptionBuilder {
	r.emptySeq = v
	return r
}

func (r HasOptionBuilder) FromTuple(t fp.Tuple4[string, fp.Option[string], []string, []int]) HasOptionBuilder {
	r.message = t.I1
	r.addr = t.I2
	r.phone = t.I3
	r.emptySeq = t.I4
	return r
}

func (r HasOptionBuilder) Apply(message string, addr fp.Option[string], phone []string, emptySeq []int) HasOptionBuilder {
	r.message = message
	r.addr = addr
	r.phone = phone
	r.emptySeq = emptySeq
	return r
}

func (r HasOptionBuilder) FromMap(m map[string]any) HasOptionBuilder {

	if v, ok := m["message"].(string); ok {
		r.message = v
	}

	if v, ok := m["addr"].(fp.Option[string]); ok {
		r.addr = v
	} else if v, ok := m["addr"].(string); ok {
		r.addr = option.Some(v)
	}

	if v, ok := m["phone"].([]string); ok {
		r.phone = v
	}

	if v, ok := m["emptySeq"].([]int); ok {
		r.emptySeq = v
	}

	return r
}

func (r HasOptionBuilder) FromLabelled(t fp.Labelled4[NamedMessageOfHasOption[string], NamedAddrOfHasOption[fp.Option[string]], NamedPhoneOfHasOption[[]string], NamedEmptySeqOfHasOption[[]int]]) HasOptionBuilder {
	r.message = t.I1.Value()
	r.addr = t.I2.Value()
	r.phone = t.I3.Value()
	r.emptySeq = t.I4.Value()
	return r
}

type HasOptionMutable struct {
	Message  string
	Addr     fp.Option[string]
	Phone    []string
	EmptySeq []int
}

func (r HasOption) AsMutable() HasOptionMutable {
	return HasOptionMutable{
		Message:  r.message,
		Addr:     r.addr,
		Phone:    r.phone,
		EmptySeq: r.emptySeq,
	}
}

func (r HasOptionMutable) AsImmutable() HasOption {
	return HasOption{
		message:  r.Message,
		addr:     r.Addr,
		phone:    r.Phone,
		emptySeq: r.EmptySeq,
	}
}

func (r CustomValue) B() int {
	return r.b
}

func (r CustomValue) WithA(v string) CustomValue {
	r.a = v
	return r
}

func (r CustomValue) String() string {
	return fmt.Sprintf("testpk1.CustomValue{a:%v, b:%v}", r.a, r.b)
}

func (r CustomValue) AsTuple() fp.Tuple2[string, int] {
	return as.Tuple2(r.a, r.b)
}

func (r CustomValue) Unapply() (string, int) {
	return r.a, r.b
}

func (r CustomValue) AsMap() map[string]any {
	m := map[string]any{}
	m["a"] = r.a
	m["b"] = r.b
	return m
}

func (r CustomValueBuilder) Build() CustomValue {
	return CustomValue(r)
}

func (r CustomValue) Builder() CustomValueBuilder {
	return CustomValueBuilder(r)
}

func (r CustomValueBuilder) A(v string) CustomValueBuilder {
	r.a = v
	return r
}

func (r CustomValueBuilder) FromTuple(t fp.Tuple2[string, int]) CustomValueBuilder {
	r.a = t.I1
	r.b = t.I2
	return r
}

func (r CustomValueBuilder) Apply(a string, b int) CustomValueBuilder {
	r.a = a
	r.b = b
	return r
}

func (r CustomValueBuilder) FromMap(m map[string]any) CustomValueBuilder {

	if v, ok := m["a"].(string); ok {
		r.a = v
	}

	if v, ok := m["b"].(int); ok {
		r.b = v
	}

	return r
}

type CustomValueMutable struct {
	A string
	B int
}

func (r CustomValue) AsMutable() CustomValueMutable {
	return CustomValueMutable{
		A: r.a,
		B: r.b,
	}
}

func (r CustomValueMutable) AsImmutable() CustomValue {
	return CustomValue{
		a: r.A,
		b: r.B,
	}
}

func (r AliasedStruct) Message() string {
	return r.message
}

func (r AliasedStruct) Timestamp() time.Time {
	return r.timestamp
}

func (r AliasedStruct) WithMessage(v string) AliasedStruct {
	r.message = v
	return r
}

func (r AliasedStruct) WithTimestamp(v time.Time) AliasedStruct {
	r.timestamp = v
	return r
}

func (r AliasedStruct) String() string {
	return fmt.Sprintf("testpk1.AliasedStruct{message:%v, timestamp:%v, Pub:%v}", r.message, r.timestamp, r.Pub)
}

func (r AliasedStruct) AsTuple() fp.Tuple3[string, time.Time, string] {
	return as.Tuple3(r.message, r.timestamp, r.Pub)
}

func (r AliasedStruct) Unapply() (string, time.Time, string) {
	return r.message, r.timestamp, r.Pub
}

func (r AliasedStruct) AsMap() map[string]any {
	m := map[string]any{}
	m["message"] = r.message
	m["timestamp"] = r.timestamp
	m["Pub"] = r.Pub
	return m
}

type AliasedStructBuilder AliasedStruct

func (r AliasedStructBuilder) Build() AliasedStruct {
	return AliasedStruct(r)
}

func (r AliasedStruct) Builder() AliasedStructBuilder {
	return AliasedStructBuilder(r)
}

func (r AliasedStructBuilder) Message(v string) AliasedStructBuilder {
	r.message = v
	return r
}

func (r AliasedStructBuilder) Timestamp(v time.Time) AliasedStructBuilder {
	r.timestamp = v
	return r
}

func (r AliasedStructBuilder) FromTuple(t fp.Tuple3[string, time.Time, string]) AliasedStructBuilder {
	r.message = t.I1
	r.timestamp = t.I2
	r.Pub = t.I3
	return r
}

func (r AliasedStructBuilder) Apply(message string, timestamp time.Time, Pub string) AliasedStructBuilder {
	r.message = message
	r.timestamp = timestamp
	r.Pub = Pub
	return r
}

func (r AliasedStructBuilder) FromMap(m map[string]any) AliasedStructBuilder {

	if v, ok := m["message"].(string); ok {
		r.message = v
	}

	if v, ok := m["timestamp"].(time.Time); ok {
		r.timestamp = v
	}

	if v, ok := m["Pub"].(string); ok {
		r.Pub = v
	}

	return r
}

type AliasedStructMutable struct {
	Message    string `hello:"message"`
	Timestamp  time.Time
	Pub        string
	_notExport string
}

func (r AliasedStruct) AsMutable() AliasedStructMutable {
	return AliasedStructMutable{
		Message:   r.message,
		Timestamp: r.timestamp,
		Pub:       r.Pub,
	}
}

func (r AliasedStructMutable) AsImmutable() AliasedStruct {
	return AliasedStruct{
		message:   r.Message,
		timestamp: r.Timestamp,
		Pub:       r.Pub,
	}
}

func (r HListInsideHList) Tp() fp.Tuple2[string, int] {
	return r.tp
}

func (r HListInsideHList) Value() string {
	return r.value
}

func (r HListInsideHList) Hello() World {
	return r.hello
}

func (r HListInsideHList) WithTp(v fp.Tuple2[string, int]) HListInsideHList {
	r.tp = v
	return r
}

func (r HListInsideHList) WithValue(v string) HListInsideHList {
	r.value = v
	return r
}

func (r HListInsideHList) WithHello(v World) HListInsideHList {
	r.hello = v
	return r
}

func (r HListInsideHList) String() string {
	return fmt.Sprintf("testpk1.HListInsideHList{tp:%v, value:%v, hello:%v}", r.tp, r.value, r.hello)
}

func (r HListInsideHList) AsTuple() fp.Tuple3[fp.Tuple2[string, int], string, World] {
	return as.Tuple3(r.tp, r.value, r.hello)
}

func (r HListInsideHList) Unapply() (fp.Tuple2[string, int], string, World) {
	return r.tp, r.value, r.hello
}

func (r HListInsideHList) AsMap() map[string]any {
	m := map[string]any{}
	m["tp"] = r.tp
	m["value"] = r.value
	m["hello"] = r.hello
	return m
}

type HListInsideHListBuilder HListInsideHList

func (r HListInsideHListBuilder) Build() HListInsideHList {
	return HListInsideHList(r)
}

func (r HListInsideHList) Builder() HListInsideHListBuilder {
	return HListInsideHListBuilder(r)
}

func (r HListInsideHListBuilder) Tp(v fp.Tuple2[string, int]) HListInsideHListBuilder {
	r.tp = v
	return r
}

func (r HListInsideHListBuilder) Value(v string) HListInsideHListBuilder {
	r.value = v
	return r
}

func (r HListInsideHListBuilder) Hello(v World) HListInsideHListBuilder {
	r.hello = v
	return r
}

func (r HListInsideHListBuilder) FromTuple(t fp.Tuple3[fp.Tuple2[string, int], string, World]) HListInsideHListBuilder {
	r.tp = t.I1
	r.value = t.I2
	r.hello = t.I3
	return r
}

func (r HListInsideHListBuilder) Apply(tp fp.Tuple2[string, int], value string, hello World) HListInsideHListBuilder {
	r.tp = tp
	r.value = value
	r.hello = hello
	return r
}

func (r HListInsideHListBuilder) FromMap(m map[string]any) HListInsideHListBuilder {

	if v, ok := m["tp"].(fp.Tuple2[string, int]); ok {
		r.tp = v
	}

	if v, ok := m["value"].(string); ok {
		r.value = v
	}

	if v, ok := m["hello"].(World); ok {
		r.hello = v
	}

	return r
}

type HListInsideHListMutable struct {
	Tp    fp.Tuple2[string, int]
	Value string
	Hello World
}

func (r HListInsideHList) AsMutable() HListInsideHListMutable {
	return HListInsideHListMutable{
		Tp:    r.tp,
		Value: r.value,
		Hello: r.hello,
	}
}

func (r HListInsideHListMutable) AsImmutable() HListInsideHList {
	return HListInsideHList{
		tp:    r.Tp,
		value: r.Value,
		hello: r.Hello,
	}
}

func (r Wrapper[T]) Unwrap() T {
	return r.unwrap
}

func (r Wrapper[T]) WithUnwrap(v T) Wrapper[T] {
	r.unwrap = v
	return r
}

func (r Wrapper[T]) String() string {
	return fmt.Sprintf("testpk1.Wrapper{unwrap:%v}", r.unwrap)
}

func (r Wrapper[T]) AsTuple() fp.Tuple1[T] {
	return as.Tuple1(r.unwrap)
}

func (r Wrapper[T]) Unapply() T {
	return r.unwrap
}

func (r Wrapper[T]) AsMap() map[string]any {
	m := map[string]any{}
	m["unwrap"] = r.unwrap
	return m
}

type WrapperBuilder[T any] Wrapper[T]

func (r WrapperBuilder[T]) Build() Wrapper[T] {
	return Wrapper[T](r)
}

func (r Wrapper[T]) Builder() WrapperBuilder[T] {
	return WrapperBuilder[T](r)
}

func (r WrapperBuilder[T]) Unwrap(v T) WrapperBuilder[T] {
	r.unwrap = v
	return r
}

func (r WrapperBuilder[T]) FromTuple(t fp.Tuple1[T]) WrapperBuilder[T] {
	r.unwrap = t.I1
	return r
}

func (r WrapperBuilder[T]) Apply(unwrap T) WrapperBuilder[T] {
	r.unwrap = unwrap
	return r
}

func (r WrapperBuilder[T]) FromMap(m map[string]any) WrapperBuilder[T] {

	if v, ok := m["unwrap"].(T); ok {
		r.unwrap = v
	}

	return r
}

type WrapperMutable[T any] struct {
	Unwrap T
}

func (r Wrapper[T]) AsMutable() WrapperMutable[T] {
	return WrapperMutable[T]{
		Unwrap: r.unwrap,
	}
}

func (r WrapperMutable[T]) AsImmutable() Wrapper[T] {
	return Wrapper[T]{
		unwrap: r.Unwrap,
	}
}

func (r TestOrderedEq) List() fp.Seq[int] {
	return r.list
}

func (r TestOrderedEq) Tlist() fp.Seq[fp.Tuple2[int, int]] {
	return r.tlist
}

func (r TestOrderedEq) WithList(v fp.Seq[int]) TestOrderedEq {
	r.list = v
	return r
}

func (r TestOrderedEq) WithTlist(v fp.Seq[fp.Tuple2[int, int]]) TestOrderedEq {
	r.tlist = v
	return r
}

func (r TestOrderedEq) String() string {
	return fmt.Sprintf("testpk1.TestOrderedEq{list:%v, tlist:%v}", r.list, r.tlist)
}

func (r TestOrderedEq) AsTuple() fp.Tuple2[fp.Seq[int], fp.Seq[fp.Tuple2[int, int]]] {
	return as.Tuple2(r.list, r.tlist)
}

func (r TestOrderedEq) Unapply() (fp.Seq[int], fp.Seq[fp.Tuple2[int, int]]) {
	return r.list, r.tlist
}

func (r TestOrderedEq) AsMap() map[string]any {
	m := map[string]any{}
	m["list"] = r.list
	m["tlist"] = r.tlist
	return m
}

type TestOrderedEqBuilder TestOrderedEq

func (r TestOrderedEqBuilder) Build() TestOrderedEq {
	return TestOrderedEq(r)
}

func (r TestOrderedEq) Builder() TestOrderedEqBuilder {
	return TestOrderedEqBuilder(r)
}

func (r TestOrderedEqBuilder) List(v fp.Seq[int]) TestOrderedEqBuilder {
	r.list = v
	return r
}

func (r TestOrderedEqBuilder) Tlist(v fp.Seq[fp.Tuple2[int, int]]) TestOrderedEqBuilder {
	r.tlist = v
	return r
}

func (r TestOrderedEqBuilder) FromTuple(t fp.Tuple2[fp.Seq[int], fp.Seq[fp.Tuple2[int, int]]]) TestOrderedEqBuilder {
	r.list = t.I1
	r.tlist = t.I2
	return r
}

func (r TestOrderedEqBuilder) Apply(list fp.Seq[int], tlist fp.Seq[fp.Tuple2[int, int]]) TestOrderedEqBuilder {
	r.list = list
	r.tlist = tlist
	return r
}

func (r TestOrderedEqBuilder) FromMap(m map[string]any) TestOrderedEqBuilder {

	if v, ok := m["list"].(fp.Seq[int]); ok {
		r.list = v
	}

	if v, ok := m["tlist"].(fp.Seq[fp.Tuple2[int, int]]); ok {
		r.tlist = v
	}

	return r
}

type TestOrderedEqMutable struct {
	List  fp.Seq[int]
	Tlist fp.Seq[fp.Tuple2[int, int]]
}

func (r TestOrderedEq) AsMutable() TestOrderedEqMutable {
	return TestOrderedEqMutable{
		List:  r.list,
		Tlist: r.tlist,
	}
}

func (r TestOrderedEqMutable) AsImmutable() TestOrderedEq {
	return TestOrderedEq{
		list:  r.List,
		tlist: r.Tlist,
	}
}

func (r MapEq) M() map[string]World {
	return r.m
}

func (r MapEq) M2() fp.Map[string, World] {
	return r.m2
}

func (r MapEq) WithM(v map[string]World) MapEq {
	r.m = v
	return r
}

func (r MapEq) WithM2(v fp.Map[string, World]) MapEq {
	r.m2 = v
	return r
}

func (r MapEq) String() string {
	return fmt.Sprintf("testpk1.MapEq{m:%v, m2:%v}", r.m, r.m2)
}

func (r MapEq) AsTuple() fp.Tuple2[map[string]World, fp.Map[string, World]] {
	return as.Tuple2(r.m, r.m2)
}

func (r MapEq) Unapply() (map[string]World, fp.Map[string, World]) {
	return r.m, r.m2
}

func (r MapEq) AsMap() map[string]any {
	m := map[string]any{}
	m["m"] = r.m
	m["m2"] = r.m2
	return m
}

type MapEqBuilder MapEq

func (r MapEqBuilder) Build() MapEq {
	return MapEq(r)
}

func (r MapEq) Builder() MapEqBuilder {
	return MapEqBuilder(r)
}

func (r MapEqBuilder) M(v map[string]World) MapEqBuilder {
	r.m = v
	return r
}

func (r MapEqBuilder) M2(v fp.Map[string, World]) MapEqBuilder {
	r.m2 = v
	return r
}

func (r MapEqBuilder) FromTuple(t fp.Tuple2[map[string]World, fp.Map[string, World]]) MapEqBuilder {
	r.m = t.I1
	r.m2 = t.I2
	return r
}

func (r MapEqBuilder) Apply(m map[string]World, m2 fp.Map[string, World]) MapEqBuilder {
	r.m = m
	r.m2 = m2
	return r
}

func (r MapEqBuilder) FromMap(m map[string]any) MapEqBuilder {

	if v, ok := m["m"].(map[string]World); ok {
		r.m = v
	}

	if v, ok := m["m2"].(fp.Map[string, World]); ok {
		r.m2 = v
	}

	return r
}

type MapEqMutable struct {
	M  map[string]World
	M2 fp.Map[string, World]
}

func (r MapEq) AsMutable() MapEqMutable {
	return MapEqMutable{
		M:  r.m,
		M2: r.m2,
	}
}

func (r MapEqMutable) AsImmutable() MapEq {
	return MapEq{
		m:  r.M,
		m2: r.M2,
	}
}

func (r SeqMonoid) V() string {
	return r.v
}

func (r SeqMonoid) S() fp.Seq[string] {
	return r.s
}

func (r SeqMonoid) M() map[string]int {
	return r.m
}

func (r SeqMonoid) M2() fp.Map[string, World] {
	return r.m2
}

func (r SeqMonoid) WithV(v string) SeqMonoid {
	r.v = v
	return r
}

func (r SeqMonoid) WithS(v fp.Seq[string]) SeqMonoid {
	r.s = v
	return r
}

func (r SeqMonoid) WithM(v map[string]int) SeqMonoid {
	r.m = v
	return r
}

func (r SeqMonoid) WithM2(v fp.Map[string, World]) SeqMonoid {
	r.m2 = v
	return r
}

func (r SeqMonoid) String() string {
	return fmt.Sprintf("testpk1.SeqMonoid{v:%v, s:%v, m:%v, m2:%v}", r.v, r.s, r.m, r.m2)
}

func (r SeqMonoid) AsTuple() fp.Tuple4[string, fp.Seq[string], map[string]int, fp.Map[string, World]] {
	return as.Tuple4(r.v, r.s, r.m, r.m2)
}

func (r SeqMonoid) Unapply() (string, fp.Seq[string], map[string]int, fp.Map[string, World]) {
	return r.v, r.s, r.m, r.m2
}

func (r SeqMonoid) AsMap() map[string]any {
	m := map[string]any{}
	m["v"] = r.v
	m["s"] = r.s
	m["m"] = r.m
	m["m2"] = r.m2
	return m
}

type SeqMonoidBuilder SeqMonoid

func (r SeqMonoidBuilder) Build() SeqMonoid {
	return SeqMonoid(r)
}

func (r SeqMonoid) Builder() SeqMonoidBuilder {
	return SeqMonoidBuilder(r)
}

func (r SeqMonoidBuilder) V(v string) SeqMonoidBuilder {
	r.v = v
	return r
}

func (r SeqMonoidBuilder) S(v fp.Seq[string]) SeqMonoidBuilder {
	r.s = v
	return r
}

func (r SeqMonoidBuilder) M(v map[string]int) SeqMonoidBuilder {
	r.m = v
	return r
}

func (r SeqMonoidBuilder) M2(v fp.Map[string, World]) SeqMonoidBuilder {
	r.m2 = v
	return r
}

func (r SeqMonoidBuilder) FromTuple(t fp.Tuple4[string, fp.Seq[string], map[string]int, fp.Map[string, World]]) SeqMonoidBuilder {
	r.v = t.I1
	r.s = t.I2
	r.m = t.I3
	r.m2 = t.I4
	return r
}

func (r SeqMonoidBuilder) Apply(v string, s fp.Seq[string], m map[string]int, m2 fp.Map[string, World]) SeqMonoidBuilder {
	r.v = v
	r.s = s
	r.m = m
	r.m2 = m2
	return r
}

func (r SeqMonoidBuilder) FromMap(m map[string]any) SeqMonoidBuilder {

	if v, ok := m["v"].(string); ok {
		r.v = v
	}

	if v, ok := m["s"].(fp.Seq[string]); ok {
		r.s = v
	}

	if v, ok := m["m"].(map[string]int); ok {
		r.m = v
	}

	if v, ok := m["m2"].(fp.Map[string, World]); ok {
		r.m2 = v
	}

	return r
}

type SeqMonoidMutable struct {
	V  string
	S  fp.Seq[string]
	M  map[string]int
	M2 fp.Map[string, World]
}

func (r SeqMonoid) AsMutable() SeqMonoidMutable {
	return SeqMonoidMutable{
		V:  r.v,
		S:  r.s,
		M:  r.m,
		M2: r.m2,
	}
}

func (r SeqMonoidMutable) AsImmutable() SeqMonoid {
	return SeqMonoid{
		v:  r.V,
		s:  r.S,
		m:  r.M,
		m2: r.M2,
	}
}

func (r MapEqParam[K, V]) M() fp.Map[K, V] {
	return r.m
}

func (r MapEqParam[K, V]) WithM(v fp.Map[K, V]) MapEqParam[K, V] {
	r.m = v
	return r
}

func (r MapEqParam[K, V]) String() string {
	return fmt.Sprintf("testpk1.MapEqParam{m:%v}", r.m)
}

func (r MapEqParam[K, V]) AsTuple() fp.Tuple1[fp.Map[K, V]] {
	return as.Tuple1(r.m)
}

func (r MapEqParam[K, V]) Unapply() fp.Map[K, V] {
	return r.m
}

func (r MapEqParam[K, V]) AsMap() map[string]any {
	m := map[string]any{}
	m["m"] = r.m
	return m
}

type MapEqParamBuilder[K any, V any] MapEqParam[K, V]

func (r MapEqParamBuilder[K, V]) Build() MapEqParam[K, V] {
	return MapEqParam[K, V](r)
}

func (r MapEqParam[K, V]) Builder() MapEqParamBuilder[K, V] {
	return MapEqParamBuilder[K, V](r)
}

func (r MapEqParamBuilder[K, V]) M(v fp.Map[K, V]) MapEqParamBuilder[K, V] {
	r.m = v
	return r
}

func (r MapEqParamBuilder[K, V]) FromTuple(t fp.Tuple1[fp.Map[K, V]]) MapEqParamBuilder[K, V] {
	r.m = t.I1
	return r
}

func (r MapEqParamBuilder[K, V]) Apply(m fp.Map[K, V]) MapEqParamBuilder[K, V] {
	r.m = m
	return r
}

func (r MapEqParamBuilder[K, V]) FromMap(m map[string]any) MapEqParamBuilder[K, V] {

	if v, ok := m["m"].(fp.Map[K, V]); ok {
		r.m = v
	}

	return r
}

type MapEqParamMutable[K any, V any] struct {
	M fp.Map[K, V]
}

func (r MapEqParam[K, V]) AsMutable() MapEqParamMutable[K, V] {
	return MapEqParamMutable[K, V]{
		M: r.m,
	}
}

func (r MapEqParamMutable[K, V]) AsImmutable() MapEqParam[K, V] {
	return MapEqParam[K, V]{
		m: r.M,
	}
}

func (r NotUsedProblem) M() MapEqParam[string, int] {
	return r.m
}

func (r NotUsedProblem) WithM(v MapEqParam[string, int]) NotUsedProblem {
	r.m = v
	return r
}

func (r NotUsedProblem) String() string {
	return fmt.Sprintf("testpk1.NotUsedProblem{m:%v}", r.m)
}

func (r NotUsedProblem) AsTuple() fp.Tuple1[MapEqParam[string, int]] {
	return as.Tuple1(r.m)
}

func (r NotUsedProblem) Unapply() MapEqParam[string, int] {
	return r.m
}

func (r NotUsedProblem) AsMap() map[string]any {
	m := map[string]any{}
	m["m"] = r.m
	return m
}

type NotUsedProblemBuilder NotUsedProblem

func (r NotUsedProblemBuilder) Build() NotUsedProblem {
	return NotUsedProblem(r)
}

func (r NotUsedProblem) Builder() NotUsedProblemBuilder {
	return NotUsedProblemBuilder(r)
}

func (r NotUsedProblemBuilder) M(v MapEqParam[string, int]) NotUsedProblemBuilder {
	r.m = v
	return r
}

func (r NotUsedProblemBuilder) FromTuple(t fp.Tuple1[MapEqParam[string, int]]) NotUsedProblemBuilder {
	r.m = t.I1
	return r
}

func (r NotUsedProblemBuilder) Apply(m MapEqParam[string, int]) NotUsedProblemBuilder {
	r.m = m
	return r
}

func (r NotUsedProblemBuilder) FromMap(m map[string]any) NotUsedProblemBuilder {

	if v, ok := m["m"].(MapEqParam[string, int]); ok {
		r.m = v
	}

	return r
}

type NotUsedProblemMutable struct {
	M MapEqParam[string, int]
}

func (r NotUsedProblem) AsMutable() NotUsedProblemMutable {
	return NotUsedProblemMutable{
		M: r.m,
	}
}

func (r NotUsedProblemMutable) AsImmutable() NotUsedProblem {
	return NotUsedProblem{
		m: r.M,
	}
}

func (r Node) Value() string {
	return r.value
}

func (r Node) Left() *Node {
	return r.left
}

func (r Node) Right() *Node {
	return r.right
}

func (r Node) WithValue(v string) Node {
	r.value = v
	return r
}

func (r Node) WithLeft(v *Node) Node {
	r.left = v
	return r
}

func (r Node) WithRight(v *Node) Node {
	r.right = v
	return r
}

func (r Node) String() string {
	return fmt.Sprintf("testpk1.Node{value:%v, left:%v, right:%v}", r.value, r.left, r.right)
}

func (r Node) AsTuple() fp.Tuple3[string, *Node, *Node] {
	return as.Tuple3(r.value, r.left, r.right)
}

func (r Node) Unapply() (string, *Node, *Node) {
	return r.value, r.left, r.right
}

func (r Node) AsMap() map[string]any {
	m := map[string]any{}
	m["value"] = r.value
	m["left"] = r.left
	m["right"] = r.right
	return m
}

type NodeBuilder Node

func (r NodeBuilder) Build() Node {
	return Node(r)
}

func (r Node) Builder() NodeBuilder {
	return NodeBuilder(r)
}

func (r NodeBuilder) Value(v string) NodeBuilder {
	r.value = v
	return r
}

func (r NodeBuilder) Left(v *Node) NodeBuilder {
	r.left = v
	return r
}

func (r NodeBuilder) Right(v *Node) NodeBuilder {
	r.right = v
	return r
}

func (r NodeBuilder) FromTuple(t fp.Tuple3[string, *Node, *Node]) NodeBuilder {
	r.value = t.I1
	r.left = t.I2
	r.right = t.I3
	return r
}

func (r NodeBuilder) Apply(value string, left *Node, right *Node) NodeBuilder {
	r.value = value
	r.left = left
	r.right = right
	return r
}

func (r NodeBuilder) FromMap(m map[string]any) NodeBuilder {

	if v, ok := m["value"].(string); ok {
		r.value = v
	}

	if v, ok := m["left"].(*Node); ok {
		r.left = v
	}

	if v, ok := m["right"].(*Node); ok {
		r.right = v
	}

	return r
}

type NodeMutable struct {
	Value string
	Left  *Node
	Right *Node
}

func (r Node) AsMutable() NodeMutable {
	return NodeMutable{
		Value: r.value,
		Left:  r.left,
		Right: r.right,
	}
}

func (r NodeMutable) AsImmutable() Node {
	return Node{
		value: r.Value,
		left:  r.Left,
		right: r.Right,
	}
}

func (r NoPrivate) String() string {
	return fmt.Sprintf("testpk1.NoPrivate{Value:%v}", r.Value)
}

func (r NoPrivate) AsTuple() fp.Tuple1[int] {
	return as.Tuple1(r.Value)
}

func (r NoPrivate) Unapply() int {
	return r.Value
}

func (r NoPrivate) AsMap() map[string]any {
	m := map[string]any{}
	m["Value"] = r.Value
	return m
}

type NoPrivateBuilder NoPrivate

func (r NoPrivateBuilder) Build() NoPrivate {
	return NoPrivate(r)
}

func (r NoPrivate) Builder() NoPrivateBuilder {
	return NoPrivateBuilder(r)
}

func (r NoPrivateBuilder) FromTuple(t fp.Tuple1[int]) NoPrivateBuilder {
	r.Value = t.I1
	return r
}

func (r NoPrivateBuilder) Apply(Value int) NoPrivateBuilder {
	r.Value = Value
	return r
}

func (r NoPrivateBuilder) FromMap(m map[string]any) NoPrivateBuilder {

	if v, ok := m["Value"].(int); ok {
		r.Value = v
	}

	return r
}

type NoPrivateMutable struct {
	Value int
}

func (r NoPrivate) AsMutable() NoPrivateMutable {
	return NoPrivateMutable{
		Value: r.Value,
	}
}

func (r NoPrivateMutable) AsImmutable() NoPrivate {
	return NoPrivate{
		Value: r.Value,
	}
}

func (r Over21) I1() int {
	return r.i1
}

func (r Over21) I2() int {
	return r.i2
}

func (r Over21) I3() int {
	return r.i3
}

func (r Over21) I4() int {
	return r.i4
}

func (r Over21) I5() int {
	return r.i5
}

func (r Over21) I6() int {
	return r.i6
}

func (r Over21) I7() int {
	return r.i7
}

func (r Over21) I8() int {
	return r.i8
}

func (r Over21) I9() int {
	return r.i9
}

func (r Over21) I10() int {
	return r.i10
}

func (r Over21) I11() int {
	return r.i11
}

func (r Over21) I12() int {
	return r.i12
}

func (r Over21) I13() int {
	return r.i13
}

func (r Over21) I14() int {
	return r.i14
}

func (r Over21) I15() int {
	return r.i15
}

func (r Over21) I16() int {
	return r.i16
}

func (r Over21) I17() int {
	return r.i17
}

func (r Over21) I18() int {
	return r.i18
}

func (r Over21) I19() int {
	return r.i19
}

func (r Over21) I20() int {
	return r.i20
}

func (r Over21) I21() int {
	return r.i21
}

func (r Over21) I22() int {
	return r.i22
}

func (r Over21) I23() int {
	return r.i23
}

func (r Over21) I24() int {
	return r.i24
}

func (r Over21) I25() int {
	return r.i25
}

func (r Over21) I26() int {
	return r.i26
}

func (r Over21) I27() int {
	return r.i27
}

func (r Over21) I28() int {
	return r.i28
}

func (r Over21) I29() int {
	return r.i29
}

func (r Over21) I30() int {
	return r.i30
}

func (r Over21) WithI1(v int) Over21 {
	r.i1 = v
	return r
}

func (r Over21) WithI2(v int) Over21 {
	r.i2 = v
	return r
}

func (r Over21) WithI3(v int) Over21 {
	r.i3 = v
	return r
}

func (r Over21) WithI4(v int) Over21 {
	r.i4 = v
	return r
}

func (r Over21) WithI5(v int) Over21 {
	r.i5 = v
	return r
}

func (r Over21) WithI6(v int) Over21 {
	r.i6 = v
	return r
}

func (r Over21) WithI7(v int) Over21 {
	r.i7 = v
	return r
}

func (r Over21) WithI8(v int) Over21 {
	r.i8 = v
	return r
}

func (r Over21) WithI9(v int) Over21 {
	r.i9 = v
	return r
}

func (r Over21) WithI10(v int) Over21 {
	r.i10 = v
	return r
}

func (r Over21) WithI11(v int) Over21 {
	r.i11 = v
	return r
}

func (r Over21) WithI12(v int) Over21 {
	r.i12 = v
	return r
}

func (r Over21) WithI13(v int) Over21 {
	r.i13 = v
	return r
}

func (r Over21) WithI14(v int) Over21 {
	r.i14 = v
	return r
}

func (r Over21) WithI15(v int) Over21 {
	r.i15 = v
	return r
}

func (r Over21) WithI16(v int) Over21 {
	r.i16 = v
	return r
}

func (r Over21) WithI17(v int) Over21 {
	r.i17 = v
	return r
}

func (r Over21) WithI18(v int) Over21 {
	r.i18 = v
	return r
}

func (r Over21) WithI19(v int) Over21 {
	r.i19 = v
	return r
}

func (r Over21) WithI20(v int) Over21 {
	r.i20 = v
	return r
}

func (r Over21) WithI21(v int) Over21 {
	r.i21 = v
	return r
}

func (r Over21) WithI22(v int) Over21 {
	r.i22 = v
	return r
}

func (r Over21) WithI23(v int) Over21 {
	r.i23 = v
	return r
}

func (r Over21) WithI24(v int) Over21 {
	r.i24 = v
	return r
}

func (r Over21) WithI25(v int) Over21 {
	r.i25 = v
	return r
}

func (r Over21) WithI26(v int) Over21 {
	r.i26 = v
	return r
}

func (r Over21) WithI27(v int) Over21 {
	r.i27 = v
	return r
}

func (r Over21) WithI28(v int) Over21 {
	r.i28 = v
	return r
}

func (r Over21) WithI29(v int) Over21 {
	r.i29 = v
	return r
}

func (r Over21) WithI30(v int) Over21 {
	r.i30 = v
	return r
}

func (r Over21) String() string {
	return fmt.Sprintf("testpk1.Over21{i1:%v, i2:%v, i3:%v, i4:%v, i5:%v, i6:%v, i7:%v, i8:%v, i9:%v, i10:%v, i11:%v, i12:%v, i13:%v, i14:%v, i15:%v, i16:%v, i17:%v, i18:%v, i19:%v, i20:%v, i21:%v, i22:%v, i23:%v, i24:%v, i25:%v, i26:%v, i27:%v, i28:%v, i29:%v, i30:%v}", r.i1, r.i2, r.i3, r.i4, r.i5, r.i6, r.i7, r.i8, r.i9, r.i10, r.i11, r.i12, r.i13, r.i14, r.i15, r.i16, r.i17, r.i18, r.i19, r.i20, r.i21, r.i22, r.i23, r.i24, r.i25, r.i26, r.i27, r.i28, r.i29, r.i30)
}

func (r Over21) Unapply() (int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int) {
	return r.i1, r.i2, r.i3, r.i4, r.i5, r.i6, r.i7, r.i8, r.i9, r.i10, r.i11, r.i12, r.i13, r.i14, r.i15, r.i16, r.i17, r.i18, r.i19, r.i20, r.i21, r.i22, r.i23, r.i24, r.i25, r.i26, r.i27, r.i28, r.i29, r.i30
}

func (r Over21) AsMap() map[string]any {
	m := map[string]any{}
	m["i1"] = r.i1
	m["i2"] = r.i2
	m["i3"] = r.i3
	m["i4"] = r.i4
	m["i5"] = r.i5
	m["i6"] = r.i6
	m["i7"] = r.i7
	m["i8"] = r.i8
	m["i9"] = r.i9
	m["i10"] = r.i10
	m["i11"] = r.i11
	m["i12"] = r.i12
	m["i13"] = r.i13
	m["i14"] = r.i14
	m["i15"] = r.i15
	m["i16"] = r.i16
	m["i17"] = r.i17
	m["i18"] = r.i18
	m["i19"] = r.i19
	m["i20"] = r.i20
	m["i21"] = r.i21
	m["i22"] = r.i22
	m["i23"] = r.i23
	m["i24"] = r.i24
	m["i25"] = r.i25
	m["i26"] = r.i26
	m["i27"] = r.i27
	m["i28"] = r.i28
	m["i29"] = r.i29
	m["i30"] = r.i30
	return m
}

type NamedI1OfOver21[T any] fp.Tuple1[T]

func (r NamedI1OfOver21[T]) Name() string {
	return "i1"
}
func (r NamedI1OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI1OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI1OfOver21[T]) WithValue(v T) NamedI1OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI2OfOver21[T any] fp.Tuple1[T]

func (r NamedI2OfOver21[T]) Name() string {
	return "i2"
}
func (r NamedI2OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI2OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI2OfOver21[T]) WithValue(v T) NamedI2OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI3OfOver21[T any] fp.Tuple1[T]

func (r NamedI3OfOver21[T]) Name() string {
	return "i3"
}
func (r NamedI3OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI3OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI3OfOver21[T]) WithValue(v T) NamedI3OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI4OfOver21[T any] fp.Tuple1[T]

func (r NamedI4OfOver21[T]) Name() string {
	return "i4"
}
func (r NamedI4OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI4OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI4OfOver21[T]) WithValue(v T) NamedI4OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI5OfOver21[T any] fp.Tuple1[T]

func (r NamedI5OfOver21[T]) Name() string {
	return "i5"
}
func (r NamedI5OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI5OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI5OfOver21[T]) WithValue(v T) NamedI5OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI6OfOver21[T any] fp.Tuple1[T]

func (r NamedI6OfOver21[T]) Name() string {
	return "i6"
}
func (r NamedI6OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI6OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI6OfOver21[T]) WithValue(v T) NamedI6OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI7OfOver21[T any] fp.Tuple1[T]

func (r NamedI7OfOver21[T]) Name() string {
	return "i7"
}
func (r NamedI7OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI7OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI7OfOver21[T]) WithValue(v T) NamedI7OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI8OfOver21[T any] fp.Tuple1[T]

func (r NamedI8OfOver21[T]) Name() string {
	return "i8"
}
func (r NamedI8OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI8OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI8OfOver21[T]) WithValue(v T) NamedI8OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI9OfOver21[T any] fp.Tuple1[T]

func (r NamedI9OfOver21[T]) Name() string {
	return "i9"
}
func (r NamedI9OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI9OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI9OfOver21[T]) WithValue(v T) NamedI9OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI10OfOver21[T any] fp.Tuple1[T]

func (r NamedI10OfOver21[T]) Name() string {
	return "i10"
}
func (r NamedI10OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI10OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI10OfOver21[T]) WithValue(v T) NamedI10OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI11OfOver21[T any] fp.Tuple1[T]

func (r NamedI11OfOver21[T]) Name() string {
	return "i11"
}
func (r NamedI11OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI11OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI11OfOver21[T]) WithValue(v T) NamedI11OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI12OfOver21[T any] fp.Tuple1[T]

func (r NamedI12OfOver21[T]) Name() string {
	return "i12"
}
func (r NamedI12OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI12OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI12OfOver21[T]) WithValue(v T) NamedI12OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI13OfOver21[T any] fp.Tuple1[T]

func (r NamedI13OfOver21[T]) Name() string {
	return "i13"
}
func (r NamedI13OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI13OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI13OfOver21[T]) WithValue(v T) NamedI13OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI14OfOver21[T any] fp.Tuple1[T]

func (r NamedI14OfOver21[T]) Name() string {
	return "i14"
}
func (r NamedI14OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI14OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI14OfOver21[T]) WithValue(v T) NamedI14OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI15OfOver21[T any] fp.Tuple1[T]

func (r NamedI15OfOver21[T]) Name() string {
	return "i15"
}
func (r NamedI15OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI15OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI15OfOver21[T]) WithValue(v T) NamedI15OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI16OfOver21[T any] fp.Tuple1[T]

func (r NamedI16OfOver21[T]) Name() string {
	return "i16"
}
func (r NamedI16OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI16OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI16OfOver21[T]) WithValue(v T) NamedI16OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI17OfOver21[T any] fp.Tuple1[T]

func (r NamedI17OfOver21[T]) Name() string {
	return "i17"
}
func (r NamedI17OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI17OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI17OfOver21[T]) WithValue(v T) NamedI17OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI18OfOver21[T any] fp.Tuple1[T]

func (r NamedI18OfOver21[T]) Name() string {
	return "i18"
}
func (r NamedI18OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI18OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI18OfOver21[T]) WithValue(v T) NamedI18OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI19OfOver21[T any] fp.Tuple1[T]

func (r NamedI19OfOver21[T]) Name() string {
	return "i19"
}
func (r NamedI19OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI19OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI19OfOver21[T]) WithValue(v T) NamedI19OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI20OfOver21[T any] fp.Tuple1[T]

func (r NamedI20OfOver21[T]) Name() string {
	return "i20"
}
func (r NamedI20OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI20OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI20OfOver21[T]) WithValue(v T) NamedI20OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI21OfOver21[T any] fp.Tuple1[T]

func (r NamedI21OfOver21[T]) Name() string {
	return "i21"
}
func (r NamedI21OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI21OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI21OfOver21[T]) WithValue(v T) NamedI21OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI22OfOver21[T any] fp.Tuple1[T]

func (r NamedI22OfOver21[T]) Name() string {
	return "i22"
}
func (r NamedI22OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI22OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI22OfOver21[T]) WithValue(v T) NamedI22OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI23OfOver21[T any] fp.Tuple1[T]

func (r NamedI23OfOver21[T]) Name() string {
	return "i23"
}
func (r NamedI23OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI23OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI23OfOver21[T]) WithValue(v T) NamedI23OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI24OfOver21[T any] fp.Tuple1[T]

func (r NamedI24OfOver21[T]) Name() string {
	return "i24"
}
func (r NamedI24OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI24OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI24OfOver21[T]) WithValue(v T) NamedI24OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI25OfOver21[T any] fp.Tuple1[T]

func (r NamedI25OfOver21[T]) Name() string {
	return "i25"
}
func (r NamedI25OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI25OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI25OfOver21[T]) WithValue(v T) NamedI25OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI26OfOver21[T any] fp.Tuple1[T]

func (r NamedI26OfOver21[T]) Name() string {
	return "i26"
}
func (r NamedI26OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI26OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI26OfOver21[T]) WithValue(v T) NamedI26OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI27OfOver21[T any] fp.Tuple1[T]

func (r NamedI27OfOver21[T]) Name() string {
	return "i27"
}
func (r NamedI27OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI27OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI27OfOver21[T]) WithValue(v T) NamedI27OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI28OfOver21[T any] fp.Tuple1[T]

func (r NamedI28OfOver21[T]) Name() string {
	return "i28"
}
func (r NamedI28OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI28OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI28OfOver21[T]) WithValue(v T) NamedI28OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI29OfOver21[T any] fp.Tuple1[T]

func (r NamedI29OfOver21[T]) Name() string {
	return "i29"
}
func (r NamedI29OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI29OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI29OfOver21[T]) WithValue(v T) NamedI29OfOver21[T] {
	r.I1 = v
	return r
}

type NamedI30OfOver21[T any] fp.Tuple1[T]

func (r NamedI30OfOver21[T]) Name() string {
	return "i30"
}
func (r NamedI30OfOver21[T]) Value() T {
	return r.I1
}
func (r NamedI30OfOver21[T]) Tag() string {
	return ``
}
func (r NamedI30OfOver21[T]) WithValue(v T) NamedI30OfOver21[T] {
	r.I1 = v
	return r
}

type Over21Builder Over21

func (r Over21Builder) Build() Over21 {
	return Over21(r)
}

func (r Over21) Builder() Over21Builder {
	return Over21Builder(r)
}

func (r Over21Builder) I1(v int) Over21Builder {
	r.i1 = v
	return r
}

func (r Over21Builder) I2(v int) Over21Builder {
	r.i2 = v
	return r
}

func (r Over21Builder) I3(v int) Over21Builder {
	r.i3 = v
	return r
}

func (r Over21Builder) I4(v int) Over21Builder {
	r.i4 = v
	return r
}

func (r Over21Builder) I5(v int) Over21Builder {
	r.i5 = v
	return r
}

func (r Over21Builder) I6(v int) Over21Builder {
	r.i6 = v
	return r
}

func (r Over21Builder) I7(v int) Over21Builder {
	r.i7 = v
	return r
}

func (r Over21Builder) I8(v int) Over21Builder {
	r.i8 = v
	return r
}

func (r Over21Builder) I9(v int) Over21Builder {
	r.i9 = v
	return r
}

func (r Over21Builder) I10(v int) Over21Builder {
	r.i10 = v
	return r
}

func (r Over21Builder) I11(v int) Over21Builder {
	r.i11 = v
	return r
}

func (r Over21Builder) I12(v int) Over21Builder {
	r.i12 = v
	return r
}

func (r Over21Builder) I13(v int) Over21Builder {
	r.i13 = v
	return r
}

func (r Over21Builder) I14(v int) Over21Builder {
	r.i14 = v
	return r
}

func (r Over21Builder) I15(v int) Over21Builder {
	r.i15 = v
	return r
}

func (r Over21Builder) I16(v int) Over21Builder {
	r.i16 = v
	return r
}

func (r Over21Builder) I17(v int) Over21Builder {
	r.i17 = v
	return r
}

func (r Over21Builder) I18(v int) Over21Builder {
	r.i18 = v
	return r
}

func (r Over21Builder) I19(v int) Over21Builder {
	r.i19 = v
	return r
}

func (r Over21Builder) I20(v int) Over21Builder {
	r.i20 = v
	return r
}

func (r Over21Builder) I21(v int) Over21Builder {
	r.i21 = v
	return r
}

func (r Over21Builder) I22(v int) Over21Builder {
	r.i22 = v
	return r
}

func (r Over21Builder) I23(v int) Over21Builder {
	r.i23 = v
	return r
}

func (r Over21Builder) I24(v int) Over21Builder {
	r.i24 = v
	return r
}

func (r Over21Builder) I25(v int) Over21Builder {
	r.i25 = v
	return r
}

func (r Over21Builder) I26(v int) Over21Builder {
	r.i26 = v
	return r
}

func (r Over21Builder) I27(v int) Over21Builder {
	r.i27 = v
	return r
}

func (r Over21Builder) I28(v int) Over21Builder {
	r.i28 = v
	return r
}

func (r Over21Builder) I29(v int) Over21Builder {
	r.i29 = v
	return r
}

func (r Over21Builder) I30(v int) Over21Builder {
	r.i30 = v
	return r
}

func (r Over21Builder) Apply(i1 int, i2 int, i3 int, i4 int, i5 int, i6 int, i7 int, i8 int, i9 int, i10 int, i11 int, i12 int, i13 int, i14 int, i15 int, i16 int, i17 int, i18 int, i19 int, i20 int, i21 int, i22 int, i23 int, i24 int, i25 int, i26 int, i27 int, i28 int, i29 int, i30 int) Over21Builder {
	r.i1 = i1
	r.i2 = i2
	r.i3 = i3
	r.i4 = i4
	r.i5 = i5
	r.i6 = i6
	r.i7 = i7
	r.i8 = i8
	r.i9 = i9
	r.i10 = i10
	r.i11 = i11
	r.i12 = i12
	r.i13 = i13
	r.i14 = i14
	r.i15 = i15
	r.i16 = i16
	r.i17 = i17
	r.i18 = i18
	r.i19 = i19
	r.i20 = i20
	r.i21 = i21
	r.i22 = i22
	r.i23 = i23
	r.i24 = i24
	r.i25 = i25
	r.i26 = i26
	r.i27 = i27
	r.i28 = i28
	r.i29 = i29
	r.i30 = i30
	return r
}

func (r Over21Builder) FromMap(m map[string]any) Over21Builder {

	if v, ok := m["i1"].(int); ok {
		r.i1 = v
	}

	if v, ok := m["i2"].(int); ok {
		r.i2 = v
	}

	if v, ok := m["i3"].(int); ok {
		r.i3 = v
	}

	if v, ok := m["i4"].(int); ok {
		r.i4 = v
	}

	if v, ok := m["i5"].(int); ok {
		r.i5 = v
	}

	if v, ok := m["i6"].(int); ok {
		r.i6 = v
	}

	if v, ok := m["i7"].(int); ok {
		r.i7 = v
	}

	if v, ok := m["i8"].(int); ok {
		r.i8 = v
	}

	if v, ok := m["i9"].(int); ok {
		r.i9 = v
	}

	if v, ok := m["i10"].(int); ok {
		r.i10 = v
	}

	if v, ok := m["i11"].(int); ok {
		r.i11 = v
	}

	if v, ok := m["i12"].(int); ok {
		r.i12 = v
	}

	if v, ok := m["i13"].(int); ok {
		r.i13 = v
	}

	if v, ok := m["i14"].(int); ok {
		r.i14 = v
	}

	if v, ok := m["i15"].(int); ok {
		r.i15 = v
	}

	if v, ok := m["i16"].(int); ok {
		r.i16 = v
	}

	if v, ok := m["i17"].(int); ok {
		r.i17 = v
	}

	if v, ok := m["i18"].(int); ok {
		r.i18 = v
	}

	if v, ok := m["i19"].(int); ok {
		r.i19 = v
	}

	if v, ok := m["i20"].(int); ok {
		r.i20 = v
	}

	if v, ok := m["i21"].(int); ok {
		r.i21 = v
	}

	if v, ok := m["i22"].(int); ok {
		r.i22 = v
	}

	if v, ok := m["i23"].(int); ok {
		r.i23 = v
	}

	if v, ok := m["i24"].(int); ok {
		r.i24 = v
	}

	if v, ok := m["i25"].(int); ok {
		r.i25 = v
	}

	if v, ok := m["i26"].(int); ok {
		r.i26 = v
	}

	if v, ok := m["i27"].(int); ok {
		r.i27 = v
	}

	if v, ok := m["i28"].(int); ok {
		r.i28 = v
	}

	if v, ok := m["i29"].(int); ok {
		r.i29 = v
	}

	if v, ok := m["i30"].(int); ok {
		r.i30 = v
	}

	return r
}

type Over21Mutable struct {
	I1  int
	I2  int
	I3  int
	I4  int
	I5  int
	I6  int
	I7  int
	I8  int
	I9  int
	I10 int
	I11 int
	I12 int
	I13 int
	I14 int
	I15 int
	I16 int
	I17 int
	I18 int
	I19 int
	I20 int
	I21 int
	I22 int
	I23 int
	I24 int
	I25 int
	I26 int
	I27 int
	I28 int
	I29 int
	I30 int
}

func (r Over21) AsMutable() Over21Mutable {
	return Over21Mutable{
		I1:  r.i1,
		I2:  r.i2,
		I3:  r.i3,
		I4:  r.i4,
		I5:  r.i5,
		I6:  r.i6,
		I7:  r.i7,
		I8:  r.i8,
		I9:  r.i9,
		I10: r.i10,
		I11: r.i11,
		I12: r.i12,
		I13: r.i13,
		I14: r.i14,
		I15: r.i15,
		I16: r.i16,
		I17: r.i17,
		I18: r.i18,
		I19: r.i19,
		I20: r.i20,
		I21: r.i21,
		I22: r.i22,
		I23: r.i23,
		I24: r.i24,
		I25: r.i25,
		I26: r.i26,
		I27: r.i27,
		I28: r.i28,
		I29: r.i29,
		I30: r.i30,
	}
}

func (r Over21Mutable) AsImmutable() Over21 {
	return Over21{
		i1:  r.I1,
		i2:  r.I2,
		i3:  r.I3,
		i4:  r.I4,
		i5:  r.I5,
		i6:  r.I6,
		i7:  r.I7,
		i8:  r.I8,
		i9:  r.I9,
		i10: r.I10,
		i11: r.I11,
		i12: r.I12,
		i13: r.I13,
		i14: r.I14,
		i15: r.I15,
		i16: r.I16,
		i17: r.I17,
		i18: r.I18,
		i19: r.I19,
		i20: r.I20,
		i21: r.I21,
		i22: r.I22,
		i23: r.I23,
		i24: r.I24,
		i25: r.I25,
		i26: r.I26,
		i27: r.I27,
		i28: r.I28,
		i29: r.I29,
		i30: r.I30,
	}
}

func (r DefinedOtherPackage) PrivField() string {
	return r.privField
}

func (r DefinedOtherPackage) WithPrivField(v string) DefinedOtherPackage {
	r.privField = v
	return r
}

func (r DefinedOtherPackage) String() string {
	return fmt.Sprintf("testpk1.DefinedOtherPackage{PubField:%v, privField:%v, DupGetter:%v}", r.PubField, r.privField, r.DupGetter)
}

func (r DefinedOtherPackage) AsTuple() fp.Tuple3[string, string, string] {
	return as.Tuple3(r.PubField, r.privField, r.DupGetter)
}

func (r DefinedOtherPackage) Unapply() (string, string, string) {
	return r.PubField, r.privField, r.DupGetter
}

func (r DefinedOtherPackage) AsMap() map[string]any {
	m := map[string]any{}
	m["PubField"] = r.PubField
	m["privField"] = r.privField
	m["DupGetter"] = r.DupGetter
	return m
}

type DefinedOtherPackageBuilder DefinedOtherPackage

func (r DefinedOtherPackageBuilder) Build() DefinedOtherPackage {
	return DefinedOtherPackage(r)
}

func (r DefinedOtherPackage) Builder() DefinedOtherPackageBuilder {
	return DefinedOtherPackageBuilder(r)
}

func (r DefinedOtherPackageBuilder) PrivField(v string) DefinedOtherPackageBuilder {
	r.privField = v
	return r
}

func (r DefinedOtherPackageBuilder) FromTuple(t fp.Tuple3[string, string, string]) DefinedOtherPackageBuilder {
	r.PubField = t.I1
	r.privField = t.I2
	r.DupGetter = t.I3
	return r
}

func (r DefinedOtherPackageBuilder) Apply(PubField string, privField string, DupGetter string) DefinedOtherPackageBuilder {
	r.PubField = PubField
	r.privField = privField
	r.DupGetter = DupGetter
	return r
}

func (r DefinedOtherPackageBuilder) FromMap(m map[string]any) DefinedOtherPackageBuilder {

	if v, ok := m["PubField"].(string); ok {
		r.PubField = v
	}

	if v, ok := m["privField"].(string); ok {
		r.privField = v
	}

	if v, ok := m["DupGetter"].(string); ok {
		r.DupGetter = v
	}

	return r
}

type DefinedOtherPackageMutable struct {
	PubField  string
	PrivField string
	DupGetter string
}

func (r DefinedOtherPackage) AsMutable() DefinedOtherPackageMutable {
	return DefinedOtherPackageMutable{
		PubField:  r.PubField,
		PrivField: r.privField,
		DupGetter: r.DupGetter,
	}
}

func (r DefinedOtherPackageMutable) AsImmutable() DefinedOtherPackage {
	return DefinedOtherPackage{
		PubField:  r.PubField,
		privField: r.PrivField,
		DupGetter: r.DupGetter,
	}
}

func NewExplicitTag(ctx context.Context, hello string, world int, vExplicitTag string) ExplicitTag {
	return ExplicitTag{
		ctx:         ctx,
		hello:       hello,
		world:       world,
		ExplicitTag: vExplicitTag,
	}
}

func (r ExplicitTag) Ctx() context.Context {
	return r.ctx
}

func (r ExplicitTag) Hello() string {
	return r.hello
}

func (r ExplicitTag) World() int {
	return r.world
}

func (r ExplicitTag) WithCtx(v context.Context) ExplicitTag {
	r.ctx = v
	return r
}

func (r ExplicitTag) WithHello(v string) ExplicitTag {
	r.hello = v
	return r
}

func (r ExplicitTag) WithWorld(v int) ExplicitTag {
	r.world = v
	return r
}

func (r ExplicitTag) String() string {
	return fmt.Sprintf("testpk1.ExplicitTag{hello:%v, world:%v, ExplicitTag:%v}", r.hello, r.world, r.ExplicitTag)
}

func NewGenericExplicitTag[T any](hello string, world int, message T) GenericExplicitTag[T] {
	return GenericExplicitTag[T]{
		hello:   hello,
		world:   world,
		message: message,
	}
}

func (r GenericExplicitTag[T]) Hello() string {
	return r.hello
}

func (r GenericExplicitTag[T]) World() int {
	return r.world
}

func (r GenericExplicitTag[T]) Message() T {
	return r.message
}

func (r GenericExplicitTag[T]) WithHello(v string) GenericExplicitTag[T] {
	r.hello = v
	return r
}

func (r GenericExplicitTag[T]) WithWorld(v int) GenericExplicitTag[T] {
	r.world = v
	return r
}

func (r GenericExplicitTag[T]) WithMessage(v T) GenericExplicitTag[T] {
	r.message = v
	return r
}

func (r GenericExplicitTag[T]) String() string {
	return fmt.Sprintf("testpk1.GenericExplicitTag{hello:%v, world:%v, message:%v}", r.hello, r.world, r.message)
}

type GenericExplicitTagBuilder[T any] GenericExplicitTag[T]

func (r GenericExplicitTagBuilder[T]) Build() GenericExplicitTag[T] {
	return GenericExplicitTag[T](r)
}

func (r GenericExplicitTag[T]) Builder() GenericExplicitTagBuilder[T] {
	return GenericExplicitTagBuilder[T](r)
}

func (r GenericExplicitTagBuilder[T]) Hello(v string) GenericExplicitTagBuilder[T] {
	r.hello = v
	return r
}

func (r GenericExplicitTagBuilder[T]) World(v int) GenericExplicitTagBuilder[T] {
	r.world = v
	return r
}

func (r GenericExplicitTagBuilder[T]) Message(v T) GenericExplicitTagBuilder[T] {
	r.message = v
	return r
}

func (r GenericExplicitTagBuilder[T]) FromTuple(t fp.Tuple3[string, int, T]) GenericExplicitTagBuilder[T] {
	r.hello = t.I1
	r.world = t.I2
	r.message = t.I3
	return r
}

func (r GenericExplicitTagBuilder[T]) Apply(hello string, world int, message T) GenericExplicitTagBuilder[T] {
	r.hello = hello
	r.world = world
	r.message = message
	return r
}

func (r GenericExplicitTagBuilder[T]) FromMap(m map[string]any) GenericExplicitTagBuilder[T] {

	if v, ok := m["hello"].(string); ok {
		r.hello = v
	}

	if v, ok := m["world"].(int); ok {
		r.world = v
	}

	if v, ok := m["message"].(T); ok {
		r.message = v
	}

	return r
}

func NewRequiredArgs(hello string) RequiredArgs {
	return RequiredArgs{
		hello: hello,
	}
}

func (r UseShow) Hello() string {
	return r.hello
}

func (r UseShow) World() int {
	return r.world
}

func (r UseShow) String() string {
	return ShowUseShow().Show(r)
}

func (r UseExplicitShow) Hello() string {
	return r.hello
}

func (r UseExplicitShow) World() int {
	return r.world
}

func (r UseExplicitShow) String() string {
	return ShowUseExplicitShow().Show(r)
}

func (r UseExplicitShowVar) Hello() string {
	return r.hello
}

func (r UseExplicitShowVar) World() int {
	return r.world
}

func (r UseExplicitShowVar) WithHello(v string) UseExplicitShowVar {
	r.hello = v
	return r
}

func (r UseExplicitShowVar) WithWorld(v int) UseExplicitShowVar {
	r.world = v
	return r
}

func (r UseExplicitShowVar) String() string {
	return ShowUseExplicitShowVar.Show(r)
}

func (r UseExplicitShowVar) AsTuple() fp.Tuple2[string, int] {
	return as.Tuple2(r.hello, r.world)
}

func (r UseExplicitShowVar) Unapply() (string, int) {
	return r.hello, r.world
}

func (r UseExplicitShowVar) AsMap() map[string]any {
	m := map[string]any{}
	m["hello"] = r.hello
	m["world"] = r.world
	return m
}

type UseExplicitShowVarBuilder UseExplicitShowVar

func (r UseExplicitShowVarBuilder) Build() UseExplicitShowVar {
	return UseExplicitShowVar(r)
}

func (r UseExplicitShowVar) Builder() UseExplicitShowVarBuilder {
	return UseExplicitShowVarBuilder(r)
}

func (r UseExplicitShowVarBuilder) Hello(v string) UseExplicitShowVarBuilder {
	r.hello = v
	return r
}

func (r UseExplicitShowVarBuilder) World(v int) UseExplicitShowVarBuilder {
	r.world = v
	return r
}

func (r UseExplicitShowVarBuilder) FromTuple(t fp.Tuple2[string, int]) UseExplicitShowVarBuilder {
	r.hello = t.I1
	r.world = t.I2
	return r
}

func (r UseExplicitShowVarBuilder) Apply(hello string, world int) UseExplicitShowVarBuilder {
	r.hello = hello
	r.world = world
	return r
}

func (r UseExplicitShowVarBuilder) FromMap(m map[string]any) UseExplicitShowVarBuilder {

	if v, ok := m["hello"].(string); ok {
		r.hello = v
	}

	if v, ok := m["world"].(int); ok {
		r.world = v
	}

	return r
}

type UseExplicitShowVarMutable struct {
	Hello string
	World int
}

func (r UseExplicitShowVar) AsMutable() UseExplicitShowVarMutable {
	return UseExplicitShowVarMutable{
		Hello: r.hello,
		World: r.world,
	}
}

func (r UseExplicitShowVarMutable) AsImmutable() UseExplicitShowVar {
	return UseExplicitShowVar{
		hello: r.Hello,
		world: r.World,
	}
}

func (r ShowHasTypeParam) String() string {
	return ShowShowHasTypeParam().Show(r)
}

func (r ShowConstraint[T]) String() string {
	return fmt.Sprintf("testpk1.ShowConstraint{hello:%v, world:%v, message:%v}", r.hello, r.world, r.message)
}

func (r ShowConstraintExplicit[T]) String() string {
	return ShowShowConstraintExplicit[T]().Show(r)
}
