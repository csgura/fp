// Code generated by gombok, DO NOT EDIT.
package clonetest

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/as"
	"github.com/csgura/fp/clone"
	"github.com/csgura/fp/lazy"
	"github.com/csgura/fp/product"
	"time"
)

var CloneCloneStruct = clone.Generic(
	as.Generic(
		"clonetest.CloneStruct",
		"Struct",
		fp.Compose(
			CloneStruct.AsTuple,
			as.HList2[string, int],
		),

		fp.Compose(
			product.TupleFromHList2[string, int],
			fp.Compose(
				as.Curried2(CloneStructBuilder.FromTuple)(CloneStructBuilder{}),
				CloneStructBuilder.Build,
			),
		),
	),
	clone.HCons(
		clone.Given[string](),
		clone.HCons(
			clone.Given[int](),
			clone.HNil,
		),
	),
)

var CloneHasReference = clone.Generic(
	as.Generic(
		"clonetest.HasReference",
		"Struct",
		fp.Compose(
			func(v HasReference) fp.Tuple8[*string, []int, map[string]int, RecursiveDerive, time.Time, MySeq, ValueStruct, CloneStruct] {
				return as.Tuple8(v.A, v.S, v.M, v.RD, v.T, v.MS, v.VS, v.CS)
			},
			as.HList8[*string, []int, map[string]int, RecursiveDerive, time.Time, MySeq, ValueStruct, CloneStruct],
		),

		fp.Compose(
			product.TupleFromHList8[*string, []int, map[string]int, RecursiveDerive, time.Time, MySeq, ValueStruct, CloneStruct],
			func(t fp.Tuple8[*string, []int, map[string]int, RecursiveDerive, time.Time, MySeq, ValueStruct, CloneStruct]) HasReference {
				return HasReference{
					A:  t.I1,
					S:  t.I2,
					M:  t.I3,
					RD: t.I4,
					T:  t.I5,
					MS: t.I6,
					VS: t.I7,
					CS: t.I8,
				}
			},
		),
	),
	clone.HCons(
		clone.Ptr(lazy.Call(func() fp.Clone[string] {
			return clone.Given[string]()
		})),
		clone.HCons(
			clone.Slice(clone.Given[int]()),
			clone.HCons(
				clone.GoMap(clone.Given[string](), clone.Given[int]()),
				clone.HCons(
					CloneRecursiveDerive,
					clone.HCons(
						clone.Given[time.Time](),
						clone.HCons(
							CloneMySeq,
							clone.HCons(
								CloneValueStruct,
								clone.HCons(
									CloneCloneStruct,
									clone.HNil,
								),
							),
						),
					),
				),
			),
		),
	),
)

var CloneValueStruct = clone.Generic(
	as.Generic(
		"clonetest.ValueStruct",
		"Struct",
		fp.Compose(
			ValueStruct.AsTuple,
			as.HList2[string, int],
		),

		fp.Compose(
			product.TupleFromHList2[string, int],
			fp.Compose(
				as.Curried2(ValueStructBuilder.FromTuple)(ValueStructBuilder{}),
				ValueStructBuilder.Build,
			),
		),
	),
	clone.HCons(
		clone.Given[string](),
		clone.HCons(
			clone.Given[int](),
			clone.HNil,
		),
	),
)

var CloneMySeq = clone.Generic(
	as.Generic(
		"clonetest.MySeq",
		"NewType",
		func(v MySeq) []string {
			return []string(v)
		},
		func(v []string) MySeq {
			return MySeq(v)
		},
	),
	clone.Slice(clone.Given[string]()),
)

var CloneRecursiveDerive = clone.Generic(
	as.Generic(
		"clonetest.RecursiveDerive",
		"Struct",
		fp.Compose(
			func(v RecursiveDerive) fp.Tuple1[[]string] {
				return as.Tuple1(v.S)
			},
			as.HList1[[]string],
		),

		fp.Compose(
			product.TupleFromHList1[[]string],
			func(t fp.Tuple1[[]string]) RecursiveDerive {
				return RecursiveDerive{
					S: t.I1,
				}
			},
		),
	),
	clone.HCons(
		clone.Slice(clone.Given[string]()),
		clone.HNil,
	),
)
