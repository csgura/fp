// Code generated by gombok, DO NOT EDIT.
package gendebug

import (
	"github.com/csgura/fp"
	"github.com/csgura/fp/slice"
)

// generated by gendebug.go:28

func PureSliceS[C any, A any](a A) StateT[C, fp.Slice[A]] {
	return Pure[C](slice.Pure[A](a))
}

func LiftSliceS[C any, A any](a StateT[C, A]) StateT[C, fp.Slice[A]] {
	return Map(a, slice.Pure[A])
}

func MapSliceS[C any, A any, B any](t StateT[C, fp.Slice[A]], f func(A) B) StateT[C, fp.Slice[B]] {
	return Map(t, func(ma fp.Slice[A]) fp.Slice[B] {
		return slice.FlatMap[A, B](ma, func(a A) fp.Slice[B] {
			return slice.Pure[B](f(a))
		})
	})
}

func SubFlatMapSliceS[C any, A any, B any](t StateT[C, fp.Slice[A]], f func(A) fp.Slice[B]) StateT[C, fp.Slice[B]] {
	return Map(t, func(ma fp.Slice[A]) fp.Slice[B] {
		return slice.FlatMap[A, B](ma, func(a A) fp.Slice[B] {
			return f(a)
		})
	})
}

func TraverseSliceS[C any, A any, B any](t StateT[C, fp.Slice[A]], f func(A) StateT[C, B]) StateT[C, fp.Slice[B]] {
	sequencef := func(v fp.Slice[StateT[C, B]]) StateT[C, fp.Slice[B]] {
		panic("not implemented")
	}
	return FlatMap(MapSliceS(t, f), sequencef)
}

func FlatMapSliceS[C any, A any, B any](t StateT[C, fp.Slice[A]], f func(A) StateT[C, fp.Slice[B]]) StateT[C, fp.Slice[B]] {

	flatten := func(v fp.Slice[fp.Slice[B]]) fp.Slice[B] {
		return slice.FlatMap[fp.Slice[B], B](v, fp.Id)
	}

	return Map(TraverseSliceS(t, f), flatten)

}

func FilterSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], p func(v A) bool) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Filter[A](insideValue, p)
	})
}

func AddSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], item A) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Add[A](insideValue, item)
	})
}

func AppendSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], items A) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Append[A](insideValue, items)
	})
}

func ConcatSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], tail fp.Slice[A]) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Concat[A](insideValue, tail)
	})
}

func DropSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], n int) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Drop[A](insideValue, n)
	})
}

func ExistsSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], p func(v A) bool) StateT[C, bool] {
	return Map(sliceS, func(insideValue fp.Slice[A]) bool {
		return slice.Exists[A](insideValue, p)
	})
}

func FilterNotSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], p func(v A) bool) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.FilterNot[A](insideValue, p)
	})
}

func FindSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], p func(v A) bool) StateT[C, fp.Option[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Option[A] {
		return slice.Find[A](insideValue, p)
	})
}

func ForAllSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], p func(v A) bool) StateT[C, bool] {
	return Map(sliceS, func(insideValue fp.Slice[A]) bool {
		return slice.ForAll[A](insideValue, p)
	})
}

func ForeachSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], f func(v A)) {
	Map(sliceS, func(insideValue fp.Slice[A]) error {
		slice.Foreach[A](insideValue, f)
		return nil
	})
}

func GetSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], idx int) StateT[C, fp.Option[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Option[A] {
		return slice.Get[A](insideValue, idx)
	})
}

func HeadSliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, fp.Option[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Option[A] {
		return slice.Head[A](insideValue)
	})
}

func TailSliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Tail[A](insideValue)
	})
}

func InitSliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Init[A](insideValue)
	})
}

func IsEmptySliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, bool] {
	return Map(sliceS, func(insideValue fp.Slice[A]) bool {
		return slice.IsEmpty[A](insideValue)
	})
}

func LastSliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, fp.Option[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Option[A] {
		return slice.Last[A](insideValue)
	})
}

func MakeStringSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], sep string) StateT[C, string] {
	return Map(sliceS, func(insideValue fp.Slice[A]) string {
		return slice.MakeString[A](insideValue, sep)
	})
}

func NonEmptySliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, bool] {
	return Map(sliceS, func(insideValue fp.Slice[A]) bool {
		return slice.NonEmpty[A](insideValue)
	})
}

func ReverseSliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Reverse[A](insideValue)
	})
}

func SizeSliceS[C, A any](sliceS StateT[C, fp.Slice[A]]) StateT[C, int] {
	return Map(sliceS, func(insideValue fp.Slice[A]) int {
		return slice.Size[A](insideValue)
	})
}

func TakeSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], n int) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Take[A](insideValue, n)
	})
}

func FoldSliceS[C, A any, B any](sliceS StateT[C, fp.Slice[A]], zero B, f func(B, A) B) StateT[C, B] {
	return Map(sliceS, func(insideValue fp.Slice[A]) B {
		return slice.Fold[A, B](insideValue, zero, f)
	})
}

func ScanSliceS[C, A any, B any](sliceS StateT[C, fp.Slice[A]], zero B, f func(B, A) B) StateT[C, fp.Slice[B]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[B] {
		return slice.Scan[A, B](insideValue, zero, f)
	})
}

func SortSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], ord fp.Ord[A]) StateT[C, fp.Slice[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[A] {
		return slice.Sort[A](insideValue, ord)
	})
}

func MinSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], ord fp.Ord[A]) StateT[C, fp.Option[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Option[A] {
		return slice.Min[A](insideValue, ord)
	})
}

func MaxSliceS[C, A any](sliceS StateT[C, fp.Slice[A]], ord fp.Ord[A]) StateT[C, fp.Option[A]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Option[A] {
		return slice.Max[A](insideValue, ord)
	})
}

func FilterMapSliceS[C, A any, B any](sliceS StateT[C, fp.Slice[A]], fn func(v A) fp.Option[B]) StateT[C, fp.Slice[B]] {
	return Map(sliceS, func(insideValue fp.Slice[A]) fp.Slice[B] {
		return slice.FilterMap[A, B](insideValue, fn)
	})
}
