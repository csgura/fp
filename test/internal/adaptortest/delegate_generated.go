// Code generated by gombok, DO NOT EDIT.
package adaptortest

import (
	"context"
	"io"
	"time"
)

type SpanContextAdaptor struct {
	DefaultContext context.Context
	DoHello        func(self SpanContext) string
}

func (r *SpanContextAdaptor) Deadline() (time.Time, bool) {
	return r.DeadlineImpl(r)
}

func (r *SpanContextAdaptor) DeadlineImpl(self SpanContext) (time.Time, bool) {

	if r.DefaultContext != nil {
		type impl interface {
			DeadlineImpl(self SpanContext) (time.Time, bool)
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.DeadlineImpl(self)
		}

		return r.DefaultContext.Deadline()
	}

	panic("SpanContextAdaptor.Deadline not implemented")
}

func (r *SpanContextAdaptor) Done() <-chan struct {
} {
	return r.DoneImpl(r)
}

func (r *SpanContextAdaptor) DoneImpl(self SpanContext) <-chan struct {
} {

	if r.DefaultContext != nil {
		type impl interface {
			DoneImpl(self SpanContext) <-chan struct {
			}
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.DoneImpl(self)
		}

		return r.DefaultContext.Done()
	}

	panic("SpanContextAdaptor.Done not implemented")
}

func (r *SpanContextAdaptor) Err() error {
	return r.ErrImpl(r)
}

func (r *SpanContextAdaptor) ErrImpl(self SpanContext) error {

	if r.DefaultContext != nil {
		type impl interface {
			ErrImpl(self SpanContext) error
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.ErrImpl(self)
		}

		return r.DefaultContext.Err()
	}

	panic("SpanContextAdaptor.Err not implemented")
}

func (r *SpanContextAdaptor) Hello() string {
	return r.HelloImpl(r)
}

func (r *SpanContextAdaptor) HelloImpl(self SpanContext) string {

	if r.DoHello != nil {
		return r.DoHello(self)
	}

	panic("SpanContextAdaptor.Hello not implemented")
}

func (r *SpanContextAdaptor) Value(key any) any {
	return r.ValueImpl(r, key)
}

func (r *SpanContextAdaptor) ValueImpl(self SpanContext, key any) any {

	if r.DefaultContext != nil {
		type impl interface {
			ValueImpl(self SpanContext, key any) any
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.ValueImpl(self, key)
		}

		return r.DefaultContext.Value(key)
	}

	panic("SpanContextAdaptor.Value not implemented")
}

type SpanContextEmbedding struct {
	context.Context
	io.Closer
	DoHello func(self SpanContext) string
}

func (r *SpanContextEmbedding) Hello() string {
	return r.HelloImpl(r)
}

func (r *SpanContextEmbedding) HelloImpl(self SpanContext) string {

	if r.DoHello != nil {
		return r.DoHello(self)
	}

	panic("SpanContextEmbedding.Hello not implemented")
}

type SpanTrace struct {
	context.Context
	TracerImpl TracerImpl
	DoHello    func(self SpanContext) string
}

func (r *SpanTrace) Hello() string {
	return r.HelloImpl(r)
}

func (r *SpanTrace) HelloImpl(self SpanContext) string {

	if r.DoHello != nil {
		return r.DoHello(self)
	}

	panic("SpanTrace.Hello not implemented")
}

func (r *SpanTrace) Trace(message string) {
	r.TraceImpl(r, message)
}

func (r *SpanTrace) TraceImpl(self SpanContext, message string) {

	r.TracerImpl.Trace(message)
	return

}

type SpanContextExtends struct {
	Extends        SpanContext
	DefaultContext context.Context
	DoHello        func(self SpanContext) string
}

func (r *SpanContextExtends) Deadline() (time.Time, bool) {
	return r.DeadlineImpl(r)
}

func (r *SpanContextExtends) DeadlineImpl(self SpanContext) (time.Time, bool) {

	if r.DefaultContext != nil {
		type impl interface {
			DeadlineImpl(self SpanContext) (time.Time, bool)
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.DeadlineImpl(self)
		}

		return r.DefaultContext.Deadline()
	}

	if r.Extends != nil {
		type impl interface {
			DeadlineImpl(self SpanContext) (time.Time, bool)
		}

		if super, ok := r.Extends.(impl); ok {
			return super.DeadlineImpl(self)
		}

		return r.Extends.Deadline()
	}

	panic("SpanContextExtends.Deadline not implemented")
}

func (r *SpanContextExtends) Done() <-chan struct {
} {
	return r.DoneImpl(r)
}

func (r *SpanContextExtends) DoneImpl(self SpanContext) <-chan struct {
} {

	if r.DefaultContext != nil {
		type impl interface {
			DoneImpl(self SpanContext) <-chan struct {
			}
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.DoneImpl(self)
		}

		return r.DefaultContext.Done()
	}

	if r.Extends != nil {
		type impl interface {
			DoneImpl(self SpanContext) <-chan struct {
			}
		}

		if super, ok := r.Extends.(impl); ok {
			return super.DoneImpl(self)
		}

		return r.Extends.Done()
	}

	panic("SpanContextExtends.Done not implemented")
}

func (r *SpanContextExtends) Err() error {
	return r.ErrImpl(r)
}

func (r *SpanContextExtends) ErrImpl(self SpanContext) error {

	if r.DefaultContext != nil {
		type impl interface {
			ErrImpl(self SpanContext) error
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.ErrImpl(self)
		}

		return r.DefaultContext.Err()
	}

	if r.Extends != nil {
		type impl interface {
			ErrImpl(self SpanContext) error
		}

		if super, ok := r.Extends.(impl); ok {
			return super.ErrImpl(self)
		}

		return r.Extends.Err()
	}

	panic("SpanContextExtends.Err not implemented")
}

func (r *SpanContextExtends) Hello() string {
	return r.HelloImpl(r)
}

func (r *SpanContextExtends) HelloImpl(self SpanContext) string {

	if r.DoHello != nil {
		return r.DoHello(self)
	}

	if r.Extends != nil {
		type impl interface {
			HelloImpl(self SpanContext) string
		}

		if super, ok := r.Extends.(impl); ok {
			return super.HelloImpl(self)
		}

		return r.Extends.Hello()
	}

	panic("SpanContextExtends.Hello not implemented")
}

func (r *SpanContextExtends) Value(key any) any {
	return r.ValueImpl(r, key)
}

func (r *SpanContextExtends) ValueImpl(self SpanContext, key any) any {

	if r.DefaultContext != nil {
		type impl interface {
			ValueImpl(self SpanContext, key any) any
		}

		if super, ok := r.DefaultContext.(impl); ok {
			return super.ValueImpl(self, key)
		}

		return r.DefaultContext.Value(key)
	}

	if r.Extends != nil {
		type impl interface {
			ValueImpl(self SpanContext, key any) any
		}

		if super, ok := r.Extends.(impl); ok {
			return super.ValueImpl(self, key)
		}

		return r.Extends.Value(key)
	}

	panic("SpanContextExtends.Value not implemented")
}

type ContextWrapper struct {
	context.Context
	GetValue func(key any) any
}

func (r *ContextWrapper) Value(key any) any {

	if r.GetValue != nil {
		return r.GetValue(key)
	}

	if r.Context != nil {
		return r.Context.Value(key)
	}

	panic("ContextWrapper.Value not implemented")
}

type TracerWith struct {
	Closer  Closer
	DoTrace func(self Tracer, message string)
	DoClose func(self Tracer) error
}

func (r *TracerWith) Trace(message string) {
	r.TraceImpl(r, message)
}

func (r *TracerWith) TraceImpl(self Tracer, message string) {

	if r.DoTrace != nil {
		r.DoTrace(self, message)
		return
	}

	panic("TracerWith.Trace not implemented")
}

func (r *TracerWith) Close() error {
	return r.CloseImpl(r)
}

func (r *TracerWith) CloseImpl(self Tracer) error {

	if r.DoClose != nil {
		return r.DoClose(self)
	}

	if r.Closer != nil {
		type impl interface {
			CloseImpl(self Tracer) error
		}

		if super, ok := r.Closer.(impl); ok {
			return super.CloseImpl(self)
		}

		return r.Closer.Close()
	}

	return func() error {
		return nil
	}()
}

type ComplexIntfAdaptor struct {
	Extends SimpleIntf
	DoHello func(self ComplexIntf, ctx context.Context, msg string) string
}

func (r *ComplexIntfAdaptor) Hello(ctx context.Context, msg string) string {
	return r.HelloImpl(r, ctx, msg)
}

func (r *ComplexIntfAdaptor) HelloImpl(self ComplexIntf, ctx context.Context, msg string) string {

	if r.DoHello != nil {
		return r.DoHello(self, ctx, msg)
	}

	if r.Extends != nil {
		type impl interface {
			HelloImpl(self ComplexIntf, ctx context.Context, msg string) string
		}

		if super, ok := r.Extends.(impl); ok {
			return super.HelloImpl(self, ctx, msg)
		}

		return r.Extends.Hello(msg)
	}

	panic("ComplexIntfAdaptor.Hello not implemented")
}
